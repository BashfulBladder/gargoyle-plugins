This patch should only be used to build images for Western Digital MyNet N600 & N750 routers.
* This file comprises backports of Barrier Breaker (somewhere around r40500) onto Attitude Adjustment in 2014.

* Do not use images on the WD My Net WI-FI Range Extender as only part of the patches are used here.

* Do not try to build images for other routers with this patch present - several routers had to be disabled.

Instructions:
A. Place this file in GARGOYLE_TOP_LEVEL/patches-generic
B. Remove this file: GARGOYLE_TOP_LEVEL/patches-generic/25-tplink_1043_v2_support.patch
  (I got tired of figuring out the endless 601-MIPS-ath79-add-more-register-defines.patch layered patches)
  
Images for the WD series will not be found in the gargoyle images folder - find them in :
	GARGOYLE_TOP_LEVEL/ar71xx-src/bin/ar71xx/openwrt-ar71xx-generic-mynet-n750-squashfs-factory.bin

******************************************************************************************
To extract the kernel/rootfs from a firmware image:

Required: existing toolchain - during the course of building a firmware image, GARGOYLE_TOP_LEVEL/ar71xx-src/staging_dir/host/bin
becomes populated with several firmware image utilities. binwalk doesn't work so well with these seama images.


1. Unwrap the firmware from the seama header:
	GARGOYLE_TOP_LEVEL/ar71xx-src/staging_dir/host/bin/seama -i ~/gargoyle-1.6.1.4-ar71xx-mynet-n750-squashfs-factory.bin -m type=firmware -x ~/Desktop/output

2. Find where the squashfs partition beings (which marks where the kernel ends & rootfs begins):
	strings -a -t d ~/Desktop/output | grep hsqs
		result: 1310656 hsqs
		
3. Copy u-boot, u-boot-env, devdata, devconf & kernel (using value above):
	dd if=~/Desktop/output bs=1 count=1310656 of=~/Desktop/Part1
	
4. Extract lzma compressed data (there will be an error at the end):
	lzmadec ~/Desktop/Part1 > ~/Desktop/Part1Dec
		result: lzmadec: ~/Desktop/Part1: File is corrupt

5. Copy the kernel partition out to a new file - open Part1Dec in a hex editor & after "Starting kernel at %08x..." is where the kernel beings. Shortly after that string, the hex string 0x6D000080 will appear. Copy everything from this 0x6D000080 hex string to EOF out to a new file called vmlinux.bin.lzma

6. Decompress the kernel (again with an error at the end):
lzmadec ~/Desktop/vmlinux.bin.lzma > ~/Desktop/vmlinux

Done extracting kernel -> vmlinux is the kernel

7. Copy the squashfs partion (to end of firmware image file) to a new file (the 'skip' value is from the strings command in step 2):
	dd if=~/Desktop/gargoyle-1.6.1.4-ar71xx-mynet-n750-squashfs-sysupgrade.bin bs=1 skip=1310756 of=~/Desktop/MyNet_N750.hsqs
	
8. Depending on your OS, the number of open files may need to be increased. On Mac OS X:
	sudo sysctl -w kern.maxfiles=2048
	sudo ulimit -S -n 2048
	ulimit -n 10000
	launchctl limit maxfiles

9. Extract the squashfs partition to a new folder:
	GARGOYLE_TOP_LEVEL/ar71xx-src/staging_dir/host/bin/unsquashfs4 -d ~/Desktop/output ~/Desktop/RootFS
	
Done extracting rootfs -> The RootFS folder will contain the /bin /etc/ lib folders with the executables, scripts, libraries - everything except auto-generated files (like /tmp, /proc, /dev).

******************************************************************************************
To flash firmware via tftp & uboot:

1. Set your computer to 192.168.1.10
2. Directly connect the router to your computer - router will be @ 192.168.1.1 via uboot
3. tftpboot 0x81000000 img.bin
4. erase 0x9F070000 +0xIMAGE_SIZE (if image is 8650756 bytes: erase 0x9F070000 +0x00840004)
5. cp.b 0x81000000 0x9F070000 0xIMAGE_SIZE (if image is : cp.b 0x81000000 0x9F070000 0x00840004)
6. run runtime

******************************************************************************************

To make the patch file:
	diff -pruN -x '.*' attitude_adjustment attitude_adjustment\ WD > ~/Desktop/99-WD-N600+N750.patch

******************************************************************************************

diff -pruN -x '.*' attitude_adjustment/package/mtd/src/Makefile attitude_adjustment WD/package/mtd/src/Makefile
--- attitude_adjustment/package/mtd/src/Makefile	2014-04-17 00:02:43.000000000 -0400
+++ attitude_adjustment WD/package/mtd/src/Makefile	2014-04-18 18:22:35.000000000 -0400
@@ -3,7 +3,7 @@ CFLAGS += -Wall
 
 obj = mtd.o jffs2.o crc32.o
 obj.seama = seama.o md5.o
-obj.ar71xx = trx.o
+obj.ar71xx = trx.o $(obj.seama)
 obj.brcm = trx.o
 obj.brcm47xx = $(obj.brcm)
 obj.brcm63xx = imagetag.o
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/base-files/etc/diag.sh attitude_adjustment WD/target/linux/ar71xx/base-files/etc/diag.sh
--- attitude_adjustment/target/linux/ar71xx/base-files/etc/diag.sh	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/base-files/etc/diag.sh	2014-04-19 19:41:29.000000000 -0400
@@ -86,6 +86,10 @@ get_status_led() {
 	mr600)
 		status_led="mr600:orange:power"
 		;;
+	mynet-n600 | \
+	mynet-n750)
+		status_led="wd:blue:power"
+		;;
 	mzk-w04nu | \
 	mzk-w300nh)
 		status_led="planex:green:status"
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/base-files/etc/uci-defaults/09_fix-seama-header attitude_adjustment WD/target/linux/ar71xx/base-files/etc/uci-defaults/09_fix-seama-header
--- attitude_adjustment/target/linux/ar71xx/base-files/etc/uci-defaults/09_fix-seama-header	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/base-files/etc/uci-defaults/09_fix-seama-header	2014-04-18 08:13:10.000000000 -0400
@@ -0,0 +1,21 @@
+#!/bin/sh
+#
+# Copyright (C) 2013 OpenWrt.org
+#
+
+. /lib/ar71xx.sh
+
+fix_seama_header() {
+	local part=$1
+
+	mtd fixseama $part
+}
+
+board=$(ar71xx_board_name)
+
+case "$board" in
+mynet-n600 | \
+mynet-n750)
+	fix_seama_header kernel
+	;;
+esac
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/base-files/etc/uci-defaults/leds attitude_adjustment WD/target/linux/ar71xx/base-files/etc/uci-defaults/leds
--- attitude_adjustment/target/linux/ar71xx/base-files/etc/uci-defaults/leds	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/base-files/etc/uci-defaults/leds	2014-04-19 19:48:18.000000000 -0400
@@ -76,6 +76,14 @@ mr600)
 	ucidef_set_led_wlan "wlan58" "WLAN58" "mr600:green:wlan58" "phy0tpt"
 	ucidef_set_led_wlan "wlan24" "WLAN24" "mr600:green:wlan24" "phy1tpt"
 	;;
+	
+mynet-n600)
+	ucidef_set_led_netdev "wan" "WAN" "wd:blue:internet" "eth1"
+	ucidef_set_led_switch "lan1" "LAN1" "wd:green:lan1" "switch0" "0x02"
+	ucidef_set_led_switch "lan2" "LAN2" "wd:green:lan2" "switch0" "0x10"
+	ucidef_set_led_switch "lan3" "LAN3" "wd:green:lan3" "switch0" "0x08"
+	ucidef_set_led_switch "lan4" "LAN4" "wd:green:lan4" "switch0" "0x04"
+	;;
 
 mzk-w04u)
 	ucidef_set_led_usbdev "usb" "USB" "planex:green:usb" "1-1"
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/base-files/etc/uci-defaults/network attitude_adjustment WD/target/linux/ar71xx/base-files/etc/uci-defaults/network
--- attitude_adjustment/target/linux/ar71xx/base-files/etc/uci-defaults/network	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/base-files/etc/uci-defaults/network	2014-04-19 19:51:09.000000000 -0400
@@ -182,6 +182,7 @@ dir-600-a1 |\
 dir-615-c1 |\
 dir-615-e4 |\
 ja76pf |\
+mynet-n600 |\
 rb-750 |\
 rb-751 |\
 tew-632brp |\
@@ -218,6 +219,16 @@ ew-dorin-router)
 	ucidef_add_switch "eth0" "1" "1"
 	ucidef_add_switch_vlan "eth0" "1" "0 2 3"
 	;;
+	
+mynet-n750)
+	local mac
+	ucidef_set_interfaces_lan_wan "eth0.1" "eth0.2"
+	ucidef_add_switch "switch0" "1" "1"
+	ucidef_add_switch_vlan "switch0" "1" "0t 1 2 3 4"
+	ucidef_add_switch_vlan "switch0" "2" "0t 5"
+	mac=$(mtd_get_mac_ascii devdata "wanmac")
+	[ -n "$mac" ] && ucidef_set_interface_macaddr "wan" "$mac"
+	;;
 
 *)
 	ucidef_set_interfaces_lan_wan "eth0" "eth1"
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/base-files/lib/ar71xx.sh attitude_adjustment WD/target/linux/ar71xx/base-files/lib/ar71xx.sh
--- attitude_adjustment/target/linux/ar71xx/base-files/lib/ar71xx.sh	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/base-files/lib/ar71xx.sh	2014-04-19 19:52:36.000000000 -0400
@@ -231,6 +231,12 @@ ar71xx_board_detect() {
 	*MR600)
 		name="mr600"
 		;;
+	*"My Net N600")
+		name="mynet-n600"
+		;;
+	*"My Net N750")
+		name="mynet-n750"
+		;;
 	*MZK-W04NU)
 		name="mzk-w04nu"
 		;;
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/base-files/lib/upgrade/platform.sh attitude_adjustment WD/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
--- attitude_adjustment/target/linux/ar71xx/base-files/lib/upgrade/platform.sh	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/base-files/lib/upgrade/platform.sh	2014-04-20 01:32:29.000000000 -0400
@@ -69,6 +69,10 @@ tplink_get_image_boot_size() {
 	get_image "$@" | dd bs=4 count=1 skip=37 2>/dev/null | hexdump -v -n 4 -e '1/1 "%02x"'
 }
 
+seama_get_type_magic() {
+	get_image "$@" | dd bs=1 count=4 skip=53 2>/dev/null | hexdump -v -n 4 -e '1/1 "%02x"'
+}
+
 platform_check_image() {
 	local board=$(ar71xx_board_name)
 	local magic="$(get_magic_word "$1")"
@@ -140,6 +144,21 @@ platform_check_image() {
 		dir825b_check_image "$1" && return 0
 		;;
 
+	mynet-n600 | \
+	mynet-n750)
+		[ "$magic_long" != "5ea3a417" ] && {
+			echo "Invalid image, bad magic: $magic_long"
+			return 1
+		}
+
+		local typemagic=$(seama_get_type_magic "$1")
+		[ "$typemagic" != "6669726d" ] && {
+			echo "Invalid image, bad type: $typemagic"
+			return 1
+		}
+
+		return 0;
+		;;
 	mr600 | \
 	om2p | \
 	om2p-hs | \
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/config-3.3 attitude_adjustment WD/target/linux/ar71xx/config-3.3
--- attitude_adjustment/target/linux/ar71xx/config-3.3	2014-04-16 23:59:44.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/config-3.3	2014-04-21 07:38:35.000000000 -0400
@@ -3,6 +3,7 @@ CONFIG_AG71XX_AR8216_SUPPORT=y
 # CONFIG_AG71XX_DEBUG is not set
 # CONFIG_AG71XX_DEBUG_FS is not set
 CONFIG_AR8216_PHY=y
+CONFIG_AR8216_PHY_LEDS=y
 CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
 CONFIG_ARCH_DISCARD_MEMBLOCK=y
 CONFIG_ARCH_HIBERNATION_POSSIBLE=y
@@ -25,7 +26,7 @@ CONFIG_ATH79_MACH_ALL0258N=y
 CONFIG_ATH79_MACH_ALL0315N=y
 CONFIG_ATH79_MACH_AP113=y
 CONFIG_ATH79_MACH_AP121=y
-CONFIG_ATH79_MACH_AP136=y
+# CONFIG_ATH79_MACH_AP136 is not set
 CONFIG_ATH79_MACH_AP81=y
 CONFIG_ATH79_MACH_AP83=y
 CONFIG_ATH79_MACH_AP96=y
@@ -36,7 +36,7 @@ CONFIG_ATH79_MACH_DB120=y
 CONFIG_ATH79_MACH_DIR_600_A1=y
 CONFIG_ATH79_MACH_DIR_615_C1=y
 CONFIG_ATH79_MACH_DIR_825_B1=y
-CONFIG_ATH79_MACH_DIR_825_C1=y
+# CONFIG_ATH79_MACH_DIR_825_C1 is not set
 CONFIG_ATH79_MACH_EAP7660D=y
 CONFIG_ATH79_MACH_EW_DORIN=y
 CONFIG_ATH79_MACH_HORNET_UB=y
@@ -45,12 +46,14 @@ CONFIG_ATH79_MACH_MZK_W300NH=y
 CONFIG_ATH79_MACH_NBG460N=y
 CONFIG_ATH79_MACH_OM2P=y
 CONFIG_ATH79_MACH_MR600=y
+CONFIG_ATH79_MACH_MYNET_N600=y
+CONFIG_ATH79_MACH_MYNET_N750=y
 CONFIG_ATH79_MACH_PB42=y
 CONFIG_ATH79_MACH_PB44=y
 CONFIG_ATH79_MACH_PB92=y
-CONFIG_ATH79_MACH_RB2011=y
+# CONFIG_ATH79_MACH_RB2011 is not set
 CONFIG_ATH79_MACH_RB4XX=y
-CONFIG_ATH79_MACH_RB750=y
+# CONFIG_ATH79_MACH_RB750 is not set
 CONFIG_ATH79_MACH_RW2458N=y
 CONFIG_ATH79_MACH_TEW_632BRP=y
 CONFIG_ATH79_MACH_TEW_673GRU=y
@@ -60,8 +63,8 @@ CONFIG_ATH79_MACH_TL_MR3020=y
 CONFIG_ATH79_MACH_TL_MR3X20=y
 CONFIG_ATH79_MACH_TL_WA901ND=y
 CONFIG_ATH79_MACH_TL_WA901ND_V2=y
-CONFIG_ATH79_MACH_TL_WDR4300=y
-CONFIG_ATH79_MACH_TL_WR1041N_V2=y
+# CONFIG_ATH79_MACH_TL_WDR4300 is not set
+# CONFIG_ATH79_MACH_TL_WR1041N_V2 is not set
 CONFIG_ATH79_MACH_TL_WR1043ND=y
 CONFIG_ATH79_MACH_TL_WR2543N=y
 CONFIG_ATH79_MACH_TL_WR703N=y
@@ -176,6 +179,14 @@ CONFIG_MTD_MYLOADER_PARTS=y
 CONFIG_MTD_PHYSMAP=y
 CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-2
 CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_SPLIT=y
+CONFIG_MTD_ROOTFS_ROOT_DEV=y
+CONFIG_MTD_ROOTFS_SPLIT=y
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_SPLIT_LZMA_FW=y
+CONFIG_MTD_SPLIT_SEAMA_FW=y
+CONFIG_MTD_SPLIT_SQUASHFS_ROOT=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
 CONFIG_MTD_TPLINK_PARTS=y
 CONFIG_MTD_WRT160NL_PARTS=y
 CONFIG_MYLOADER=y
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.c attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.c
--- attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.c	2014-04-16 23:59:40.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.c	2014-04-20 10:48:30.000000000 -0400
@@ -39,7 +39,7 @@ static struct resource ath79_mdio0_resou
 	}
 };
 
-static struct ag71xx_mdio_platform_data ath79_mdio0_data;
+struct ag71xx_mdio_platform_data ath79_mdio0_data;
 
 struct platform_device ath79_mdio0_device = {
 	.name		= "ag71xx-mdio",
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.h attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.h
--- attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.h	2014-04-16 23:59:40.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/dev-eth.h	2014-04-20 22:35:38.000000000 -0400
@@ -39,6 +39,7 @@ void ath79_register_eth(unsigned int id)
 
 extern struct ag71xx_switch_platform_data ath79_switch_data;
 
+extern struct ag71xx_mdio_platform_data ath79_mdio0_data;
 extern struct platform_device ath79_mdio0_device;
 extern struct platform_device ath79_mdio1_device;
 void ath79_register_mdio(unsigned int id, u32 phy_mask);
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n600.c attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n600.c
--- attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n600.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n600.c	2014-04-18 08:13:10.000000000 -0400
@@ -0,0 +1,202 @@
+/*
+ *  WD My Net N600 board support
+ *
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define MYNET_N600_GPIO_LED_WIFI	0
+#define MYNET_N600_GPIO_LED_POWER	11
+#define MYNET_N600_GPIO_LED_INTERNET	12
+#define MYNET_N600_GPIO_LED_WPS		13
+
+#define MYNET_N600_GPIO_LED_LAN1	4
+#define MYNET_N600_GPIO_LED_LAN2	3
+#define MYNET_N600_GPIO_LED_LAN3	2
+#define MYNET_N600_GPIO_LED_LAN4	1
+
+#define MYNET_N600_GPIO_BTN_RESET	16
+#define MYNET_N600_GPIO_BTN_WPS		17
+
+#define MYNET_N600_GPIO_EXTERNAL_LNA0	14
+#define MYNET_N600_GPIO_EXTERNAL_LNA1	15
+
+#define MYNET_N600_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_N600_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_N600_KEYS_POLL_INTERVAL)
+
+#define MYNET_N600_MAC0_OFFSET		0
+#define MYNET_N600_MAC1_OFFSET		6
+#define MYNET_N600_WMAC_CALDATA_OFFSET	0x1000
+#define MYNET_N600_PCIE_CALDATA_OFFSET	0x5000
+
+#define MYNET_N600_NVRAM_ADDR		0x1f058010
+#define MYNET_N600_NVRAM_SIZE		0x7ff0
+
+static struct gpio_led mynet_n600_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_N600_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wps",
+		.gpio		= MYNET_N600_GPIO_LED_WPS,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_N600_GPIO_LED_WIFI,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:internet",
+		.gpio		= MYNET_N600_GPIO_LED_INTERNET,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:green:lan1",
+		.gpio		= MYNET_N600_GPIO_LED_LAN1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan2",
+		.gpio		= MYNET_N600_GPIO_LED_LAN2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan3",
+		.gpio		= MYNET_N600_GPIO_LED_LAN3,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:green:lan4",
+		.gpio		= MYNET_N600_GPIO_LED_LAN4,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mynet_n600_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_N600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N600_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_N600_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N600_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static void mynet_n600_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_N600_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_N600_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+#define MYNET_N600_WAN_PHY_MASK	BIT(0)
+
+static void __init mynet_n600_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN1,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN2,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN3,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_LAN4,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_N600_GPIO_LED_INTERNET,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_n600_leds_gpio),
+				 mynet_n600_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MYNET_N600_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_n600_gpio_keys),
+					mynet_n600_gpio_keys);
+
+	/*
+	 * Control signal for external LNAs 0 and 1
+	 * Taken from GPL bootloader source:
+	 *   board/ar7240/db12x/alpha_gpio.c
+	 */
+	ath79_wmac_set_ext_lna_gpio(0, MYNET_N600_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, MYNET_N600_GPIO_EXTERNAL_LNA1);
+
+	mynet_n600_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + MYNET_N600_WMAC_CALDATA_OFFSET, tmpmac);
+
+	mynet_n600_get_mac("wlan5mac=", tmpmac);
+	ap91_pci_init(art + MYNET_N600_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_SW_ONLY_MODE |
+				   AR934X_ETH_CFG_SW_PHY_SWAP);
+
+	ath79_register_mdio(1, 0x0);
+
+	/* LAN */
+	mynet_n600_get_mac("lanmac=", ath79_eth1_data.mac_addr);
+
+	/* GMAC1 is connected to the internal switch */
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+
+	ath79_register_eth(1);
+
+	/* WAN */
+	mynet_n600_get_mac("wanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to the PHY4 of the internal switch */
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask = MYNET_N600_WAN_PHY_MASK;
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = MYNET_N600_WAN_PHY_MASK;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio1_device.dev;
+
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_N600, "MYNET-N600", "WD My Net N600",
+	     mynet_n600_setup);
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n750.c attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n750.c
--- attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n750.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-n750.c	2014-04-21 12:37:42.000000000 -0400
@@ -0,0 +1,226 @@
+/*
+ *  WD My Net N750 board support
+ *
+ *  Copyright (C) 2013 Felix Kaechele <felix@fetzig.org>
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+
+/*
+ * Taken from GPL bootloader source:
+ *   board/ar7240/db12x/alpha_gpio.c
+ */
+#define MYNET_N750_GPIO_LED_WIFI	11
+#define MYNET_N750_GPIO_LED_INTERNET	12
+#define MYNET_N750_GPIO_LED_WPS		13
+#define MYNET_N750_GPIO_LED_POWER	14
+
+#define MYNET_N750_GPIO_BTN_RESET	17
+#define MYNET_N750_GPIO_BTN_WPS		19
+
+#define MYNET_N750_GPIO_EXTERNAL_LNA0	15
+#define MYNET_N750_GPIO_EXTERNAL_LNA1	18
+
+#define MYNET_N750_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_N750_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_N750_KEYS_POLL_INTERVAL)
+
+#define MYNET_N750_WMAC_CALDATA_OFFSET	0x1000
+#define MYNET_N750_PCIE_CALDATA_OFFSET	0x5000
+
+#define MYNET_N750_NVRAM_ADDR		0x1f058010
+#define MYNET_N750_NVRAM_SIZE		0x7ff0
+
+static struct gpio_led mynet_n750_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_N750_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wps",
+		.gpio		= MYNET_N750_GPIO_LED_WPS,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_N750_GPIO_LED_WIFI,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:internet",
+		.gpio		= MYNET_N750_GPIO_LED_INTERNET,
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_button mynet_n750_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_N750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N750_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_N750_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_N750_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+};
+
+static const struct ar8327_led_info mynet_n750_leds_ar8327[] __initconst = {
+	AR8327_LED_INFO(PHY0_0, HW, "wd:green:lan1"),
+	AR8327_LED_INFO(PHY1_0, HW, "wd:green:lan2"),
+	AR8327_LED_INFO(PHY2_0, HW, "wd:green:lan3"),
+	AR8327_LED_INFO(PHY3_0, HW, "wd:green:lan4"),
+	AR8327_LED_INFO(PHY4_0, HW, "wd:green:wan"),
+	AR8327_LED_INFO(PHY0_1, HW, "wd:yellow:lan1"),
+	AR8327_LED_INFO(PHY1_1, HW, "wd:yellow:lan2"),
+	AR8327_LED_INFO(PHY2_1, HW, "wd:yellow:lan3"),
+	AR8327_LED_INFO(PHY3_1, HW, "wd:yellow:lan4"),
+	AR8327_LED_INFO(PHY4_1, HW, "wd:yellow:wan"),
+};
+
+static struct ar8327_pad_cfg mynet_n750_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_RGMII,
+	.txclk_delay_en = true,
+	.rxclk_delay_en = true,
+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
+};
+
+static struct ar8327_led_cfg mynet_n750_ar8327_led_cfg = {
+	.led_ctrl0 = 0xcc35cc35,
+	.led_ctrl1 = 0xca35ca35,
+	.led_ctrl2 = 0xc935c935,
+	.led_ctrl3 = 0x03ffff00,
+	.open_drain = false,
+};
+
+static struct ar8327_platform_data mynet_n750_ar8327_data = {
+	.pad0_cfg = &mynet_n750_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+	.led_cfg = &mynet_n750_ar8327_led_cfg,
+	.num_leds = ARRAY_SIZE(mynet_n750_leds_ar8327),
+	.leds = mynet_n750_leds_ar8327,
+};
+
+static struct mdio_board_info mynet_n750_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &mynet_n750_ar8327_data,
+	},
+};
+
+static void mynet_n750_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_N750_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_N750_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+/*
+ * The bootloader on this board powers down all PHYs on the switch
+ * before booting the kernel. We bring all PHYs back up so that they are
+ * discoverable by the mdio bus scan and the switch is detected
+ * correctly.
+ */
+static void mynet_n750_mdio_fixup(struct mii_bus *bus)
+{
+	int i;
+
+	for (i = 0; i < 5; i++)
+		bus->write(bus, i, MII_BMCR,
+			   (BMCR_RESET | BMCR_ANENABLE | BMCR_SPEED1000));
+
+	mdelay(1000);
+}
+
+static void __init mynet_n750_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_n750_leds_gpio),
+				 mynet_n750_leds_gpio);
+	ath79_register_gpio_keys_polled(-1, MYNET_N750_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_n750_gpio_keys),
+					mynet_n750_gpio_keys);
+	/*
+	 * Control signal for external LNAs 0 and 1
+	 * Taken from GPL bootloader source:
+	 *   board/ar7240/db12x/alpha_gpio.c
+	 */
+	ath79_wmac_set_ext_lna_gpio(0, MYNET_N750_GPIO_EXTERNAL_LNA0);
+	ath79_wmac_set_ext_lna_gpio(1, MYNET_N750_GPIO_EXTERNAL_LNA1);
+
+	mynet_n750_get_mac("wlan24mac=", tmpmac);
+	ath79_register_wmac(art + MYNET_N750_WMAC_CALDATA_OFFSET, tmpmac);
+
+	mynet_n750_get_mac("wlan5mac=", tmpmac);
+	ap91_pci_init(art + MYNET_N750_PCIE_CALDATA_OFFSET, tmpmac);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0);
+
+	mdiobus_register_board_info(mynet_n750_mdio0_info,
+				    ARRAY_SIZE(mynet_n750_mdio0_info));
+
+	ath79_mdio0_data.reset = mynet_n750_mdio_fixup;
+	ath79_register_mdio(0, 0x0);
+
+	mynet_n750_get_mac("lanmac=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to an AR8327N switch */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(0);
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_pll_data.pll_1000 = 0x06000000;
+	ath79_register_eth(0);
+
+	ath79_register_usb();
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_N750, "MYNET-N750", "WD My Net N750",
+	     mynet_n750_setup);
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-rext.c attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-rext.c
--- attitude_adjustment/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-rext.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/ath79/mach-mynet-rext.c	2014-04-18 08:13:10.000000000 -0400
@@ -0,0 +1,178 @@
+/*
+ *  WD My Net WI-FI Range Extender (Codename:Starfish db12x) board support
+ *
+ *  Copyright (C) 2013 Christian Lamparter <chunkeey@googlemail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/ar8216_platform.h>
+
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-m25p80.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+#include "nvram.h"
+
+#define MYNET_REXT_GPIO_LED_POWER	11
+#define MYNET_REXT_GPIO_LED_ETHERNET	12
+#define MYNET_REXT_GPIO_LED_WIFI	19
+
+#define MYNET_REXT_GPIO_LED_RF_QTY1	20
+#define MYNET_REXT_GPIO_LED_RF_QTY2	21
+#define MYNET_REXT_GPIO_LED_RF_QTY3	22
+
+#define MYNET_REXT_GPIO_BTN_RESET	13
+#define MYNET_REXT_GPIO_BTN_WPS		15
+#define MYNET_REXT_GPIO_SW_RF		14
+
+#define MYNET_REXT_GPIO_PHY_SWRST	16	/* disables Ethernet PHY */
+#define MYNET_REXT_GPIO_PHY_INT		17
+#define MYNET_REXT_GPIO_18		18
+
+#define MYNET_REXT_KEYS_POLL_INTERVAL	20	/* msecs */
+#define MYNET_REXT_KEYS_DEBOUNCE_INTERVAL (3 * MYNET_REXT_KEYS_POLL_INTERVAL)
+
+#define MYNET_REXT_WMAC_CALDATA_OFFSET	0x1000
+
+#define MYNET_REXT_NVRAM_ADDR		0x1f7e0010
+#define MYNET_REXT_NVRAM_SIZE		0xfff0
+
+#define MYNET_REXT_ART_ADDR		0x1f7f0000
+
+static struct gpio_led mynet_rext_leds_gpio[] __initdata = {
+	{
+		.name		= "wd:blue:power",
+		.gpio		= MYNET_REXT_GPIO_LED_POWER,
+		.active_low	= 0,
+	},
+	{
+		.name		= "wd:blue:wireless",
+		.gpio		= MYNET_REXT_GPIO_LED_WIFI,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:ethernet",
+		.gpio		= MYNET_REXT_GPIO_LED_ETHERNET,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality1",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY1,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality2",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY2,
+		.active_low	= 1,
+	},
+	{
+		.name		= "wd:blue:quality3",
+		.gpio		= MYNET_REXT_GPIO_LED_RF_QTY3,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button mynet_rext_gpio_keys[] __initdata = {
+	{
+		.desc		= "Reset button",
+		.type		= EV_KEY,
+		.code		= KEY_RESTART,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_REXT_GPIO_BTN_RESET,
+		.active_low	= 1,
+	},
+	{
+		.desc		= "WPS button",
+		.type		= EV_KEY,
+		.code		= KEY_WPS_BUTTON,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio		= MYNET_REXT_GPIO_BTN_WPS,
+		.active_low	= 1,
+	},
+	{
+		.desc           = "RF Band switch",
+		.type           = EV_SW,
+		.code           = BTN_1,
+		.debounce_interval = MYNET_REXT_KEYS_DEBOUNCE_INTERVAL,
+		.gpio           = MYNET_REXT_GPIO_SW_RF,
+	},
+};
+
+static void mynet_rext_get_mac(const char *name, char *mac)
+{
+	u8 *nvram = (u8 *) KSEG1ADDR(MYNET_REXT_NVRAM_ADDR);
+	int err;
+
+	err = ath79_nvram_parse_mac_addr(nvram, MYNET_REXT_NVRAM_SIZE,
+					 name, mac);
+	if (err)
+		pr_err("no MAC address found for %s\n", name);
+}
+
+static void __init mynet_rext_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(MYNET_REXT_ART_ADDR);
+	u8 tmpmac[ETH_ALEN];
+
+	ath79_register_m25p80(NULL);
+
+	/* GPIO configuration from drivers/char/GPIO8.c */
+
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_POWER,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_WIFI,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY1,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY2,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_RF_QTY3,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_gpio_output_select(MYNET_REXT_GPIO_LED_ETHERNET,
+				 AR934X_GPIO_OUT_GPIO);
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(mynet_rext_leds_gpio),
+				 mynet_rext_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, MYNET_REXT_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(mynet_rext_gpio_keys),
+					mynet_rext_gpio_keys);
+
+	ath79_setup_ar934x_eth_cfg(AR934X_ETH_CFG_RGMII_GMAC0 |
+				   AR934X_ETH_CFG_RXD_DELAY |
+				   AR934X_ETH_CFG_RDV_DELAY);
+
+	ath79_register_mdio(0, 0x0);
+
+	/* LAN */
+	mynet_rext_get_mac("et0macaddr=", ath79_eth0_data.mac_addr);
+
+	/* GMAC0 is connected to an external PHY on Port 4 */
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_pll_data.pll_1000 = 0x0e000000; /* athrs_mac.c */
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_register_eth(0);
+
+	/* WLAN */
+	mynet_rext_get_mac("wl0_hwaddr=", tmpmac);
+	ap91_pci_init(art + MYNET_REXT_WMAC_CALDATA_OFFSET, tmpmac);
+}
+
+MIPS_MACHINE(ATH79_MACH_MYNET_REXT, "MYNET-REXT",
+	     "WD My Net Wi-Fi Range Extender", mynet_rext_setup);
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/ag71xx_platform.h attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/ag71xx_platform.h
--- attitude_adjustment/target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/ag71xx_platform.h	2014-04-16 23:59:40.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/files/arch/mips/include/asm/mach-ath79/ag71xx_platform.h	2014-04-20 14:10:52.000000000 -0400
@@ -55,6 +55,8 @@ struct ag71xx_mdio_platform_data {
 	u8		is_ar934x:1;
 	unsigned long	mdio_clock;
 	unsigned long	ref_clock;
+	
+	void		(*reset)(struct mii_bus *bus);
 };
 
 #endif /* __ASM_MACH_ATH79_PLATFORM_H */
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c attitude_adjustment WD/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c
--- attitude_adjustment/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c	2014-04-16 23:59:41.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_mdio.c	2014-04-20 14:12:36.000000000 -0400
@@ -180,6 +180,9 @@ static int ag71xx_mdio_reset(struct mii_
 
 	ag71xx_mdio_wr(am, AG71XX_REG_MII_CFG, t);
 	udelay(100);
+	
+	if (am->pdata->reset)
+		am->pdata->reset(bus);
 
 	return 0;
 }
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/generic/profiles/wd.mk attitude_adjustment WD/target/linux/ar71xx/generic/profiles/wd.mk
--- attitude_adjustment/target/linux/ar71xx/generic/profiles/wd.mk	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/generic/profiles/wd.mk	2014-04-18 08:13:10.000000000 -0400
@@ -0,0 +1,36 @@
+#
+# Copyright (C) 2013 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+define Profile/MYNETN600
+	NAME:=WD My Net N600
+	PACKAGES:=kmod-usb-core kmod-usb2
+endef
+
+define Profile/MYNETN600/Description
+  Package set optimized for the WD My Net N600 device.
+endef
+$(eval $(call Profile,MYNETN600))
+
+define Profile/MYNETN750
+	NAME:=WD My Net N750
+	PACKAGES:=kmod-usb-core kmod-usb2
+endef
+define Profile/MYNETN750/Description
+  Package set optimized for the WD My Net N750 device.
+endef
+
+$(eval $(call Profile,MYNETN750))
+
+define Profile/MYNETREXT
+	NAME:=WD My Net Wi-Fi Range Extender
+	PACKAGES:=rssileds
+endef
+
+define Profile/MYNETREXT/Description
+  Package set optimized for the WD My Net Wi-Fi Range Extender device.
+endef
+$(eval $(call Profile,MYNETREXT))
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/image/Makefile attitude_adjustment WD/target/linux/ar71xx/image/Makefile
--- attitude_adjustment/target/linux/ar71xx/image/Makefile	2014-04-16 23:59:41.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/image/Makefile	2014-04-20 01:42:17.000000000 -0400
@@ -31,6 +31,10 @@ define mkcmdline
 $(if $(1),board=$(1) )$(if $(2),console=$(2)$(COMMA)$(3))
 endef
 
+define mtdpartsize
+$(shell sz=`echo '$(2)' | sed -ne 's/.*[:$(COMMA)]\([0-9]*\)k[@]*[0-9a-zx]*($(1)).*/\1/p'`; [ -n "$$sz" ] && echo $$(($$sz * 1024)))
+endef
+
 SINGLE_PROFILES:=
 
 define SingleProfile
@@ -184,6 +188,7 @@ whrhpg300n_mtdlayout=mtdparts=spi0.0:248
 wndr3700_mtdlayout=mtdparts=spi0.0:320k(u-boot)ro,128k(u-boot-env)ro,1024k(kernel),6656k(rootfs),64k(art)ro,7680k@0x70000(firmware)
 wndr3700v2_mtdlayout=mtdparts=spi0.0:320k(u-boot)ro,128k(u-boot-env)ro,1024k(kernel),14848k(rootfs),64k(art)ro,15872k@0x70000(firmware)
 zcn1523h_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,6208k(rootfs),1472k(kernel),64k(configure)ro,64k(mfg)ro,64k(art)ro,7680k@0x50000(firmware)
+mynet_n600_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,64k(devdata)ro,64k(devconf)ro,15872k(firmware),64k(radiocfg)ro
 
 define Image/BuildKernel
 	cp $(KDIR)/vmlinux.elf $(VMLINUX).elf
@@ -482,6 +487,37 @@ define Image/Build/ALFA/initramfs
 	$(call MkuImageLzma/initramfs,$(2),$(3) $(4))
 endef
 
+Image/Build/Seama/loader=$(call Image/BuildLoader,$(1),bin,$(2) $(3),0x80060000)
+
+define Image/Build/Seama
+	[ -e "$(KDIR)/loader-$(2).bin" ]
+	$(call CompressLzma,$(KDIR)/loader-$(2).bin,$(KDIR_TMP)/loader-$(2).bin.lzma)
+	-rm -f $(KDIR_TMP)/image-$(2).tmp
+	$(call CatFiles,$(KDIR_TMP)/loader-$(2).bin.lzma,$$$$(($(6) - 64)),$(KDIR)/root.$(1),$(7),$(KDIR_TMP)/image-$(2).tmp)
+	[ -e "$(KDIR_TMP)/image-$(2).tmp" ] && { \
+		$(STAGING_DIR_HOST)/bin/seama \
+		-i $(KDIR_TMP)/image-$(2).tmp \
+		-m "dev=/dev/mtdblock/1" -m "type=firmware"; \
+		$(STAGING_DIR_HOST)/bin/seama \
+			-s $(call imgname,$(1),$(2))-factory.bin \
+			-m "signature=$(5)" \
+			-i $(KDIR_TMP)/image-$(2).tmp.seama; \
+	}
+	cat $(KDIR_TMP)/loader-$(2).bin.lzma > $(KDIR_TMP)/image-$(2)-sysupgrade.tmp
+	$(STAGING_DIR_HOST)/bin/seama \
+		-i $(KDIR_TMP)/image-$(2)-sysupgrade.tmp \
+		-m "dev=/dev/mtdblock/1" -m "type=firmware"
+	$(call CatFiles,$(KDIR_TMP)/image-$(2)-sysupgrade.tmp.seama,$(6),$(KDIR)/root.$(1),$(7),$(call sysupname,$(1),$(2)))
+endef
+
+define Image/Build/Seama/initramfs
+	$(call PatchKernelLzma,$(2),$(3) $(4),,-initramfs)
+	$(STAGING_DIR_HOST)/bin/seama \
+		-i $(KDIR_TMP)/vmlinux-initramfs-$(2).bin.lzma \
+		-m "dev=/dev/mtdblock/1" -m "type=firmware"
+	cat $(KDIR_TMP)/vmlinux-initramfs-$(2).bin.lzma.seama > $(call imgname,initramfs,$(2))-seama.bin
+endef
+
 define Image/Build/TPLINKOLD/loader
 	$(call Image/BuildLoaderAlone,$(1),gz,$(2),0x22000,0)
 endef
@@ -850,6 +886,9 @@ $(eval $(call SingleProfile,PB4X,$(fs_64
 $(eval $(call SingleProfile,Planex,$(fs_64k),MZKW04NU,mzk-w04nu,MZK-W04NU,ttyS0,115200))
 $(eval $(call SingleProfile,Planex,$(fs_64k),MZKW300NH,mzk-w300nh,MZK-W300NH,ttyS0,115200))
 
+$(eval $(call SingleProfile,Seama,64k,MYNETN600,mynet-n600,MYNET-N600,ttyS0,115200,$$(mynet_n600_mtdlayout),wrgnd16_wd_db600,1310720,16187392))
+$(eval $(call SingleProfile,Seama,64k,MYNETN750,mynet-n750,MYNET-N750,ttyS0,115200,$$(mynet_n600_mtdlayout),wrgnd13_wd_av,1310720,16187392))
+
 $(eval $(call SingleProfile,TPLINKOLD,$(fs_squash),TLWR841NV15,tl-wr841nd-v1.5,TL-WR841N-v1.5,ttyS0,115200,0x08410002,2,4M))
 
 $(eval $(call SingleProfile,TPLINK,$(fs_64kraw),TLMR3220,tl-mr3220-v1,TL-MR3220,ttyS0,115200,0x32200001,1,4M))
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/522-MIPS-ath79-add-ath79_wmac_register_simple-helper.patch	2014-04-18 08:13:10.000000000 -0400
@@ -0,0 +1,21 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -189,3 +189,9 @@ void __init ath79_register_wmac(u8 *cal_
+ 
+ 	platform_device_register(&ath79_wmac_device);
+ }
++
++void __init ath79_register_wmac_simple(void)
++{
++	ath79_register_wmac(NULL, NULL);
++	ath79_wmac_data.eeprom_name = "soc_wmac.eeprom";
++}
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -13,5 +13,6 @@
+ #define _ATH79_DEV_WMAC_H
+ 
+ void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
++void ath79_register_wmac_simple(void);
+ 
+ #endif /* _ATH79_DEV_WMAC_H */
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/523-MIPS-ath79-OTP-support.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/523-MIPS-ath79-OTP-support.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/523-MIPS-ath79-OTP-support.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/523-MIPS-ath79-OTP-support.patch	2014-04-18 08:13:10.000000000 -0400
@@ -0,0 +1,166 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -165,6 +165,137 @@ static void qca955x_wmac_setup(void)
+ 		ath79_wmac_data.is_clk_25mhz = true;
+ }
+ 
++static bool __init
++ar93xx_wmac_otp_read_word(void __iomem *base, int addr, u32 *data)
++{
++	int timeout = 1000;
++	u32 val;
++
++	__raw_readl(base + AR9300_OTP_BASE + (4 * addr));
++	while (timeout--) {
++		val = __raw_readl(base + AR9300_OTP_STATUS);
++		if ((val & AR9300_OTP_STATUS_TYPE) == AR9300_OTP_STATUS_VALID)
++			break;
++
++		udelay(10);
++	}
++
++	if (!timeout)
++		return false;
++
++	*data = __raw_readl(base + AR9300_OTP_READ_DATA);
++	return true;
++}
++
++static bool __init
++ar93xx_wmac_otp_read(void __iomem *base, int addr, u8 *dest, int len)
++{
++	u32 data;
++	int i;
++
++	for (i = 0; i < len; i++) {
++		int offset = 8 * ((addr - i) % 4);
++
++		if (!ar93xx_wmac_otp_read_word(base, (addr - i) / 4, &data))
++			return false;
++
++		dest[i] = (data >> offset) & 0xff;
++	}
++
++	return true;
++}
++
++static bool __init
++ar93xx_wmac_otp_uncompress(void __iomem *base, int addr, int len, u8 *dest,
++			   int dest_start, int dest_len)
++{
++	int dest_bytes = 0;
++	int offset = 0;
++	int end = addr - len;
++	u8 hdr[2];
++
++	while (addr > end) {
++		if (!ar93xx_wmac_otp_read(base, addr, hdr, 2))
++			return false;
++
++		addr -= 2;
++		offset += hdr[0];
++
++		if (offset <= dest_start + dest_len &&
++		    offset + len >= dest_start) {
++			int data_offset = 0;
++			int dest_offset = 0;
++			int copy_len;
++
++			if (offset < dest_start)
++				data_offset = dest_start - offset;
++			else
++				dest_offset = offset - dest_start;
++
++			copy_len = len - data_offset;
++			if (copy_len > dest_len - dest_offset)
++				copy_len = dest_len - dest_offset;
++
++			ar93xx_wmac_otp_read(base, addr - data_offset,
++					     dest + dest_offset,
++					     copy_len);
++
++			dest_bytes += copy_len;
++		}
++		addr -= hdr[1];
++	}
++	return !!dest_bytes;
++}
++
++bool __init ar93xx_wmac_read_mac_address(u8 *dest)
++{
++	void __iomem *base;
++	bool ret = false;
++	int addr = 0x1ff;
++	unsigned int len;
++	u32 hdr_u32;
++	u8 *hdr = (u8 *) &hdr_u32;
++	u8 mac[6] = { 0x00, 0x02, 0x03, 0x04, 0x05, 0x06 };
++	int mac_start = 2, mac_end = 8;
++
++	BUG_ON(!soc_is_ar933x() && !soc_is_ar934x());
++	base = ioremap_nocache(AR933X_WMAC_BASE, AR933X_WMAC_SIZE);
++	while (addr > sizeof(hdr)) {
++		if (!ar93xx_wmac_otp_read(base, addr, hdr, sizeof(hdr)))
++			break;
++
++		if (hdr_u32 == 0 || hdr_u32 == ~0)
++			break;
++
++		len = (hdr[1] << 4) | (hdr[2] >> 4);
++		addr -= 4;
++
++		switch (hdr[0] >> 5) {
++		case 0:
++			if (len < mac_end)
++				break;
++
++			ar93xx_wmac_otp_read(base, addr - mac_start, mac, 6);
++			ret = true;
++			break;
++		case 3:
++			ret |= ar93xx_wmac_otp_uncompress(base, addr, len, mac,
++							  mac_start, 6);
++			break;
++		default:
++			break;
++		}
++
++		addr -= len + 2;
++	}
++
++	iounmap(base);
++	if (ret)
++		memcpy(dest, mac, 6);
++
++	return ret;
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -14,5 +14,6 @@
+ 
+ void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
+ void ath79_register_wmac_simple(void);
++bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
+ #endif /* _ATH79_DEV_WMAC_H */
+--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
++++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+@@ -113,6 +113,14 @@
+ #define QCA955X_EHCI1_BASE	0x1b400000
+ #define QCA955X_EHCI_SIZE	0x1000
+ 
++#define AR9300_OTP_BASE		0x14000
++#define AR9300_OTP_STATUS	0x15f18
++#define AR9300_OTP_STATUS_TYPE		0x7
++#define AR9300_OTP_STATUS_VALID		0x4
++#define AR9300_OTP_STATUS_ACCESS_BUSY	0x2
++#define AR9300_OTP_STATUS_SM_BUSY	0x1
++#define AR9300_OTP_READ_DATA	0x15f1c
++
+ /*
+  * DDR_CTRL block
+  */
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/524-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch	2014-04-18 08:13:10.000000000 -0400
@@ -0,0 +1,31 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -296,6 +296,16 @@ bool __init ar93xx_wmac_read_mac_address
+ 	return ret;
+ }
+ 
++void __init ath79_wmac_disable_2ghz(void)
++{
++	ath79_wmac_data.disable_2ghz = true;
++}
++
++void __init ath79_wmac_disable_5ghz(void)
++{
++	ath79_wmac_data.disable_5ghz = true;
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -14,6 +14,9 @@
+ 
+ void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
+ void ath79_register_wmac_simple(void);
++void ath79_wmac_disable_2ghz(void);
++void ath79_wmac_disable_5ghz(void);
++
+ bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
+ #endif /* _ATH79_DEV_WMAC_H */
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/601-MIPS-ath79-add-more-register-defines.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/601-MIPS-ath79-add-more-register-defines.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/601-MIPS-ath79-add-more-register-defines.patch	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/601-MIPS-ath79-add-more-register-defines.patch	2014-04-20 22:06:05.000000000 -0400
@@ -166,7 +166,7 @@
  #define AR934X_GPIO_REG_FUNC		0x6c
  
  #define AR71XX_GPIO_COUNT		16
-@@ -550,4 +618,139 @@
+@@ -550,4 +618,140 @@
  #define AR934X_SRIF_DPLL2_OUTDIV_SHIFT	13
  #define AR934X_SRIF_DPLL2_OUTDIV_MASK	0x7
  
@@ -238,6 +238,8 @@
 +#define AR934X_GPIO_FUNC_JTAG_DISABLE		BIT(1)
 +
 +#define AR934X_GPIO_OUT_GPIO		0x00
++#define AR934X_GPIO_OUT_EXT_LNA0       46
++#define AR934X_GPIO_OUT_EXT_LNA1       47
 +
 +/*
 + * MII_CTRL block
@@ -304,5 +306,4 @@
 +
 +#define QCA955X_ETH_CFG_RGMII_GMAC0	BIT(0)
 +#define QCA955X_ETH_CFG_SGMII_GMAC0	BIT(6)
-+
  #endif /* __ASM_MACH_AR71XX_REGS_H */
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/605-MIPS-ath79-db120-fixes.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/605-MIPS-ath79-db120-fixes.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/605-MIPS-ath79-db120-fixes.patch	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/605-MIPS-ath79-db120-fixes.patch	2014-04-21 19:56:43.000000000 -0400
@@ -1,5 +1,5 @@
---- a/arch/mips/ath79/mach-db120.c
-+++ b/arch/mips/ath79/mach-db120.c
+--- a/arch/mips/ath79/mach-db120.c	2014-04-21 15:25:08.000000000 -0400
++++ b/arch/mips/ath79/mach-db120 2.c	2014-04-21 15:35:41.000000000 -0400
 @@ -2,7 +2,7 @@
   * Atheros DB120 reference board support
   *
@@ -9,7 +9,7 @@
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
-@@ -19,16 +19,26 @@
+@@ -19,16 +19,25 @@
   */
  
  #include <linux/pci.h>
@@ -20,7 +20,6 @@
  
 -#include "machtypes.h"
 +#include <asm/mach-ath79/ar71xx_regs.h>
-+
 +#include "common.h"
 +#include "dev-ap9x-pci.h"
 +#include "dev-eth.h"
@@ -38,7 +37,7 @@
  #define DB120_GPIO_LED_WLAN_5G		12
  #define DB120_GPIO_LED_WLAN_2G		13
  #define DB120_GPIO_LED_STATUS		14
-@@ -39,8 +49,10 @@
+@@ -39,8 +48,10 @@
  #define DB120_KEYS_POLL_INTERVAL	20	/* msecs */
  #define DB120_KEYS_DEBOUNCE_INTERVAL	(3 * DB120_KEYS_POLL_INTERVAL)
  
@@ -51,7 +50,7 @@
  
  static struct gpio_led db120_leds_gpio[] __initdata = {
  	{
-@@ -63,6 +75,11 @@ static struct gpio_led db120_leds_gpio[]
+@@ -63,6 +74,11 @@ static struct gpio_led db120_leds_gpio[]
  		.gpio		= DB120_GPIO_LED_WLAN_2G,
  		.active_low	= 1,
  	},
@@ -63,7 +62,7 @@
  };
  
  static struct gpio_keys_button db120_gpio_keys[] __initdata = {
-@@ -76,66 +93,85 @@ static struct gpio_keys_button db120_gpi
+@@ -76,66 +92,85 @@ static struct gpio_keys_button db120_gpi
  	},
  };
  
@@ -99,7 +98,7 @@
 -	.num_chipselect	= 1,
 +static struct ar8327_platform_data db120_ar8327_data = {
 +	.pad0_cfg = &db120_ar8327_pad0_cfg,
-+	.cpuport_cfg = {
++	.port0_cfg = {
 +		.force_link = 1,
 +		.speed = AR8327_PORT_SPEED_1000,
 +		.duplex = 1,
@@ -145,10 +144,10 @@
  static void __init db120_setup(void)
  {
  	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
- 
++	
 +	ath79_gpio_output_select(DB120_GPIO_LED_USB, AR934X_GPIO_OUT_GPIO);
 +	ath79_register_m25p80(NULL);
-+
+ 
  	ath79_register_leds_gpio(-1, ARRAY_SIZE(db120_leds_gpio),
  				 db120_leds_gpio);
  	ath79_register_gpio_keys_polled(-1, DB120_KEYS_POLL_INTERVAL,
@@ -191,19 +190,3 @@
  }
  
  MIPS_MACHINE(ATH79_MACH_DB120, "DB120", "Atheros DB120 reference board",
---- a/arch/mips/ath79/Kconfig
-+++ b/arch/mips/ath79/Kconfig
-@@ -43,9 +43,12 @@ config ATH79_MACH_AP81
- config ATH79_MACH_DB120
- 	bool "Atheros DB120 reference board"
- 	select SOC_AR934X
-+	select ATH79_DEV_AP9X_PCI if PCI
-+	select ATH79_DEV_ETH
- 	select ATH79_DEV_GPIO_BUTTONS
- 	select ATH79_DEV_LEDS_GPIO
--	select ATH79_DEV_SPI
-+	select ATH79_DEV_M25P80
-+	select ATH79_DEV_NFC
- 	select ATH79_DEV_USB
- 	select ATH79_DEV_WMAC
- 	help
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/609-MIPS-ath79-ap136-fixes.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/609-MIPS-ath79-ap136-fixes.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/609-MIPS-ath79-ap136-fixes.patch	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/609-MIPS-ath79-ap136-fixes.patch	1969-12-31 19:00:00.000000000 -0500
@@ -1,184 +0,0 @@
---- a/arch/mips/ath79/mach-ap136.c
-+++ b/arch/mips/ath79/mach-ap136.c
-@@ -1,5 +1,5 @@
- /*
-- * Qualcomm Atheros AP136 reference board support
-+ * Atheros AP136 reference board support
-  *
-  * Copyright (c) 2012 Qualcomm Atheros
-  * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
-@@ -18,23 +18,27 @@
-  *
-  */
- 
--#include <linux/pci.h>
--#include <linux/ath9k_platform.h>
-+#include <linux/platform_device.h>
-+#include <linux/ar8216_platform.h>
- 
--#include "machtypes.h"
-+#include <asm/mach-ath79/ar71xx_regs.h>
-+
-+#include "common.h"
-+#include "dev-ap9x-pci.h"
- #include "dev-gpio-buttons.h"
-+#include "dev-eth.h"
- #include "dev-leds-gpio.h"
--#include "dev-spi.h"
-+#include "dev-m25p80.h"
- #include "dev-usb.h"
- #include "dev-wmac.h"
--#include "pci.h"
-+#include "machtypes.h"
- 
--#define AP136_GPIO_LED_STATUS_RED	14
--#define AP136_GPIO_LED_STATUS_GREEN	19
- #define AP136_GPIO_LED_USB		4
--#define AP136_GPIO_LED_WLAN_2G		13
- #define AP136_GPIO_LED_WLAN_5G		12
-+#define AP136_GPIO_LED_WLAN_2G		13
-+#define AP136_GPIO_LED_STATUS_RED	14
- #define AP136_GPIO_LED_WPS_RED		15
-+#define AP136_GPIO_LED_STATUS_GREEN	19
- #define AP136_GPIO_LED_WPS_GREEN	20
- 
- #define AP136_GPIO_BTN_WPS		16
-@@ -43,8 +47,10 @@
- #define AP136_KEYS_POLL_INTERVAL	20	/* msecs */
- #define AP136_KEYS_DEBOUNCE_INTERVAL	(3 * AP136_KEYS_POLL_INTERVAL)
- 
--#define AP136_WMAC_CALDATA_OFFSET 0x1000
--#define AP136_PCIE_CALDATA_OFFSET 0x5000
-+#define AP136_MAC0_OFFSET		0
-+#define AP136_MAC1_OFFSET		6
-+#define AP136_WMAC_CALDATA_OFFSET	0x1000
-+#define AP136_PCIE_CALDATA_OFFSET	0x5000
- 
- static struct gpio_led ap136_leds_gpio[] __initdata = {
- 	{
-@@ -98,63 +104,91 @@ static struct gpio_keys_button ap136_gpi
- 	},
- };
- 
--static struct ath79_spi_controller_data ap136_spi0_data = {
--	.cs_type = ATH79_SPI_CS_TYPE_INTERNAL,
--	.cs_line = 0,
-+static struct ar8327_pad_cfg ap136_ar8327_pad0_cfg = {
-+	.mode = AR8327_PAD_MAC_RGMII,
-+	.txclk_delay_en = true,
-+	.rxclk_delay_en = true,
-+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL1,
-+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL2,
- };
- 
--static struct spi_board_info ap136_spi_info[] = {
--	{
--		.bus_num	= 0,
--		.chip_select	= 0,
--		.max_speed_hz	= 25000000,
--		.modalias	= "mx25l6405d",
--		.controller_data = &ap136_spi0_data,
--	}
-+static struct ar8327_pad_cfg ap136_ar8327_pad6_cfg = {
-+	.mode = AR8327_PAD_MAC_SGMII,
-+	.txclk_delay_en = false,
-+	.rxclk_delay_en = true,
-+	.txclk_delay_sel = AR8327_CLK_DELAY_SEL0,
-+	.rxclk_delay_sel = AR8327_CLK_DELAY_SEL0,
- };
- 
--static struct ath79_spi_platform_data ap136_spi_data = {
--	.bus_num	= 0,
--	.num_chipselect	= 1,
-+static struct ar8327_platform_data ap136_ar8327_data = {
-+	.pad0_cfg = &ap136_ar8327_pad0_cfg,
-+	.pad6_cfg = &ap136_ar8327_pad6_cfg,
-+	.cpuport_cfg = {
-+		.force_link = 1,
-+		.speed = AR8327_PORT_SPEED_1000,
-+		.duplex = 1,
-+		.txpause = 1,
-+		.rxpause = 1,
-+	}
- };
- 
--#ifdef CONFIG_PCI
--static struct ath9k_platform_data ap136_ath9k_data;
-+static struct mdio_board_info ap136_mdio0_info[] = {
-+	{
-+		.bus_id = "ag71xx-mdio.0",
-+		.phy_addr = 0,
-+		.platform_data = &ap136_ar8327_data,
-+	},
-+};
- 
--static int ap136_pci_plat_dev_init(struct pci_dev *dev)
-+static void __init ap136_gmac_setup(void)
- {
--	if (dev->bus->number == 1 && (PCI_SLOT(dev->devfn)) == 0)
--		dev->dev.platform_data = &ap136_ath9k_data;
-+	void __iomem *base;
-+	u32 t;
- 
--	return 0;
--}
-+	base = ioremap(QCA955X_GMAC_BASE, QCA955X_GMAC_SIZE);
- 
--static void __init ap136_pci_init(u8 *eeprom)
--{
--	memcpy(ap136_ath9k_data.eeprom_data, eeprom,
--	       sizeof(ap136_ath9k_data.eeprom_data));
-+	t = __raw_readl(base + QCA955X_GMAC_REG_ETH_CFG);
-+
-+	t &= ~(QCA955X_ETH_CFG_RGMII_GMAC0 | QCA955X_ETH_CFG_SGMII_GMAC0);
-+	t |= QCA955X_ETH_CFG_RGMII_GMAC0;
- 
--	ath79_pci_set_plat_dev_init(ap136_pci_plat_dev_init);
--	ath79_register_pci();
-+	__raw_writel(t, base + QCA955X_GMAC_REG_ETH_CFG);
-+
-+	iounmap(base);
- }
--#else
--static inline void ap136_pci_init(void) {}
--#endif /* CONFIG_PCI */
- 
- static void __init ap136_setup(void)
- {
- 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
- 
-+	ath79_register_m25p80(NULL);
-+
- 	ath79_register_leds_gpio(-1, ARRAY_SIZE(ap136_leds_gpio),
- 				 ap136_leds_gpio);
- 	ath79_register_gpio_keys_polled(-1, AP136_KEYS_POLL_INTERVAL,
- 					ARRAY_SIZE(ap136_gpio_keys),
- 					ap136_gpio_keys);
--	ath79_register_spi(&ap136_spi_data, ap136_spi_info,
--			   ARRAY_SIZE(ap136_spi_info));
-+
- 	ath79_register_usb();
--	ath79_register_wmac(art + AP136_WMAC_CALDATA_OFFSET);
--	ap136_pci_init(art + AP136_PCIE_CALDATA_OFFSET);
-+	ath79_register_wmac(art + AP136_WMAC_CALDATA_OFFSET, NULL);
-+	ap91_pci_init(art + AP136_PCIE_CALDATA_OFFSET, NULL);
-+
-+	ap136_gmac_setup();
-+
-+	ath79_register_mdio(0, 0x0);
-+
-+	ath79_init_mac(ath79_eth0_data.mac_addr, art + AP136_MAC0_OFFSET, 0);
-+
-+	mdiobus_register_board_info(ap136_mdio0_info,
-+				    ARRAY_SIZE(ap136_mdio0_info));
-+
-+	/* GMAC0 is connected to an AR8327 switch */
-+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RGMII;
-+	ath79_eth0_data.phy_mask = BIT(0);
-+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
-+	ath79_eth0_pll_data.pll_1000 = 0xa6000000;
-+
-+	ath79_register_eth(0);
- }
- 
- MIPS_MACHINE(ATH79_MACH_AP136, "AP136", "Atheros AP136 reference board",
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/613-MIPS-ath79-add-ath79_wmac_setup_ext_lna_gpio-helper.patch	2014-04-20 00:01:21.000000000 -0400
@@ -0,0 +1,76 @@
+--- a/arch/mips/ath79/dev-wmac.c
++++ b/arch/mips/ath79/dev-wmac.c
+@@ -18,9 +18,11 @@
+ #include <linux/etherdevice.h>
+ #include <linux/platform_device.h>
+ #include <linux/ath9k_platform.h>
++#include <linux/gpio.h>
+ 
+ #include <asm/mach-ath79/ath79.h>
+ #include <asm/mach-ath79/ar71xx_regs.h>
++#include "common.h"
+ #include "dev-wmac.h"
+ 
+ static u8 ath79_wmac_mac[ETH_ALEN];
+@@ -311,6 +313,51 @@ void __init ath79_wmac_set_tx_gain_buffa
+ 	ath79_wmac_data.tx_gain_buffalo = true;
+ }
+ 
++static int ath79_request_ext_lna_gpio(unsigned chain, int gpio)
++{
++	char buf[32];
++	char *label;
++	int err;
++
++	scnprintf(buf, sizeof(buf), "external LNA%u", chain);
++	label = kstrdup(buf, GFP_KERNEL);
++
++	err = gpio_request_one(gpio, GPIOF_DIR_OUT | GPIOF_INIT_LOW, label);
++	if (err) {
++		pr_err("unable to request GPIO%d for external LNA%u\n",
++			gpio, chain);
++		kfree(label);
++	}
++
++	return err;
++}
++
++static void ar934x_set_ext_lna_gpio(unsigned chain, int gpio)
++{
++	unsigned int sel;
++	int err;
++
++	if (WARN_ON(chain > 1))
++		return;
++
++	err = ath79_request_ext_lna_gpio(chain, gpio);
++	if (err)
++		return;
++
++	if (chain == 0)
++		sel = AR934X_GPIO_OUT_EXT_LNA0;
++	else
++		sel = AR934X_GPIO_OUT_EXT_LNA1;
++
++	ath79_gpio_output_select(gpio, sel);
++}
++
++void __init ath79_wmac_set_ext_lna_gpio(unsigned chain, int gpio)
++{
++	if (soc_is_ar934x())
++		ar934x_set_ext_lna_gpio(chain, gpio);
++}
++
+ void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
+ {
+ 	if (soc_is_ar913x())
+--- a/arch/mips/ath79/dev-wmac.h
++++ b/arch/mips/ath79/dev-wmac.h
+@@ -16,6 +16,7 @@
+ void ath79_register_wmac_simple(void);
+ void ath79_wmac_disable_2ghz(void);
+ void ath79_wmac_disable_5ghz(void);
++void ath79_wmac_set_ext_lna_gpio(unsigned chain, int gpio);
+ 
+ bool ar93xx_wmac_read_mac_address(u8 *dest);
+ 
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/620-MIPS-ath79-OTP-support.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/620-MIPS-ath79-OTP-support.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/620-MIPS-ath79-OTP-support.patch	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/620-MIPS-ath79-OTP-support.patch	1969-12-31 19:00:00.000000000 -0500
@@ -1,166 +0,0 @@
---- a/arch/mips/ath79/dev-wmac.c
-+++ b/arch/mips/ath79/dev-wmac.c
-@@ -148,6 +148,137 @@ static void qca955x_wmac_setup(void)
- 		ath79_wmac_data.is_clk_25mhz = true;
- }
- 
-+static bool __init
-+ar93xx_wmac_otp_read_word(void __iomem *base, int addr, u32 *data)
-+{
-+	int timeout = 1000;
-+	u32 val;
-+
-+	__raw_readl(base + AR9300_OTP_BASE + (4 * addr));
-+	while (timeout--) {
-+		val = __raw_readl(base + AR9300_OTP_STATUS);
-+		if ((val & AR9300_OTP_STATUS_TYPE) == AR9300_OTP_STATUS_VALID)
-+			break;
-+
-+		udelay(10);
-+	}
-+
-+	if (!timeout)
-+		return false;
-+
-+	*data = __raw_readl(base + AR9300_OTP_READ_DATA);
-+	return true;
-+}
-+
-+static bool __init
-+ar93xx_wmac_otp_read(void __iomem *base, int addr, u8 *dest, int len)
-+{
-+	u32 data;
-+	int i;
-+
-+	for (i = 0; i < len; i++) {
-+		int offset = 8 * ((addr - i) % 4);
-+
-+		if (!ar93xx_wmac_otp_read_word(base, (addr - i) / 4, &data))
-+			return false;
-+
-+		dest[i] = (data >> offset) & 0xff;
-+	}
-+
-+	return true;
-+}
-+
-+static bool __init
-+ar93xx_wmac_otp_uncompress(void __iomem *base, int addr, int len, u8 *dest,
-+			   int dest_start, int dest_len)
-+{
-+	int dest_bytes = 0;
-+	int offset = 0;
-+	int end = addr - len;
-+	u8 hdr[2];
-+
-+	while (addr > end) {
-+		if (!ar93xx_wmac_otp_read(base, addr, hdr, 2))
-+			return false;
-+
-+		addr -= 2;
-+		offset += hdr[0];
-+
-+		if (offset <= dest_start + dest_len &&
-+		    offset + len >= dest_start) {
-+			int data_offset = 0;
-+			int dest_offset = 0;
-+			int copy_len;
-+
-+			if (offset < dest_start)
-+				data_offset = dest_start - offset;
-+			else
-+				dest_offset = offset - dest_start;
-+
-+			copy_len = len - data_offset;
-+			if (copy_len > dest_len - dest_offset)
-+				copy_len = dest_len - dest_offset;
-+
-+			ar93xx_wmac_otp_read(base, addr - data_offset,
-+					     dest + dest_offset,
-+					     copy_len);
-+
-+			dest_bytes += copy_len;
-+		}
-+		addr -= hdr[1];
-+	}
-+	return !!dest_bytes;
-+}
-+
-+bool __init ar93xx_wmac_read_mac_address(u8 *dest)
-+{
-+	void __iomem *base;
-+	bool ret = false;
-+	int addr = 0x1ff;
-+	unsigned int len;
-+	u32 hdr_u32;
-+	u8 *hdr = (u8 *) &hdr_u32;
-+	u8 mac[6] = { 0x00, 0x02, 0x03, 0x04, 0x05, 0x06 };
-+	int mac_start = 2, mac_end = 8;
-+
-+	BUG_ON(!soc_is_ar933x() && !soc_is_ar934x());
-+	base = ioremap_nocache(AR933X_WMAC_BASE, AR933X_WMAC_SIZE);
-+	while (addr > sizeof(hdr)) {
-+		if (!ar93xx_wmac_otp_read(base, addr, hdr, sizeof(hdr)))
-+			break;
-+
-+		if (hdr_u32 == 0 || hdr_u32 == ~0)
-+			break;
-+
-+		len = (hdr[1] << 4) | (hdr[2] >> 4);
-+		addr -= 4;
-+
-+		switch (hdr[0] >> 5) {
-+		case 0:
-+			if (len < mac_end)
-+				break;
-+
-+			ar93xx_wmac_otp_read(base, addr - mac_start, mac, 6);
-+			ret = true;
-+			break;
-+		case 3:
-+			ret |= ar93xx_wmac_otp_uncompress(base, addr, len, mac,
-+							  mac_start, 6);
-+			break;
-+		default:
-+			break;
-+		}
-+
-+		addr -= len + 2;
-+	}
-+
-+	iounmap(base);
-+	if (ret)
-+		memcpy(dest, mac, 6);
-+
-+	return ret;
-+}
-+
- void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
- {
- 	if (soc_is_ar913x())
---- a/arch/mips/ath79/dev-wmac.h
-+++ b/arch/mips/ath79/dev-wmac.h
-@@ -13,5 +13,6 @@
- #define _ATH79_DEV_WMAC_H
- 
- void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
-+bool ar93xx_wmac_read_mac_address(u8 *dest);
- 
- #endif /* _ATH79_DEV_WMAC_H */
---- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
-+++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
-@@ -129,6 +129,14 @@
- #define QCA955X_NFC_BASE	0x1b000200
- #define QCA955X_NFC_SIZE	0xb8
- 
-+#define AR9300_OTP_BASE		0x14000
-+#define AR9300_OTP_STATUS	0x15f18
-+#define AR9300_OTP_STATUS_TYPE		0x7
-+#define AR9300_OTP_STATUS_VALID		0x4
-+#define AR9300_OTP_STATUS_ACCESS_BUSY	0x2
-+#define AR9300_OTP_STATUS_SM_BUSY	0x1
-+#define AR9300_OTP_READ_DATA	0x15f1c
-+
- /*
-  * DDR_CTRL block
-  */
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/621-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/621-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/621-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch	2014-04-16 23:59:43.000000000 -0400
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/621-MIPS-ath79-add-ath79_wmac_disable_25ghz-helpers.patch	1969-12-31 19:00:00.000000000 -0500
@@ -1,31 +0,0 @@
---- a/arch/mips/ath79/dev-wmac.c
-+++ b/arch/mips/ath79/dev-wmac.c
-@@ -279,6 +279,16 @@ bool __init ar93xx_wmac_read_mac_address
- 	return ret;
- }
- 
-+void __init ath79_wmac_disable_2ghz(void)
-+{
-+	ath79_wmac_data.disable_2ghz = true;
-+}
-+
-+void __init ath79_wmac_disable_5ghz(void)
-+{
-+	ath79_wmac_data.disable_5ghz = true;
-+}
-+
- void __init ath79_register_wmac(u8 *cal_data, u8 *mac_addr)
- {
- 	if (soc_is_ar913x())
---- a/arch/mips/ath79/dev-wmac.h
-+++ b/arch/mips/ath79/dev-wmac.h
-@@ -13,6 +13,9 @@
- #define _ATH79_DEV_WMAC_H
- 
- void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
-+void ath79_wmac_disable_2ghz(void);
-+void ath79_wmac_disable_5ghz(void);
-+
- bool ar93xx_wmac_read_mac_address(u8 *dest);
- 
- #endif /* _ATH79_DEV_WMAC_H */
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/626-MIPS-ath79-add-MyNet-600-support.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/626-MIPS-ath79-add-MyNet-600-support.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/626-MIPS-ath79-add-MyNet-600-support.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/626-MIPS-ath79-add-MyNet-600-support.patch	2013-09-19 18:36:39.000000000 -0400
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -759,6 +759,16 @@ config ATH79_MACH_UBNT_XM
+ 	  Say 'Y' here if you want your kernel to support the
+ 	  Ubiquiti Networks XM (rev 1.0) board.
+ 
++config ATH79_MACH_MYNET_N600
++	bool "WD My Net N600 board support"
++	select SOC_AR934X
++	select ATH79_DEV_ETH
++	select ATH79_DEV_GPIO_BUTTONS
++	select ATH79_DEV_LEDS_GPIO
++	select ATH79_DEV_M25P80
++	select ATH79_DEV_WMAC
++	select ATH79_NVRAM
++
+ config ATH79_MACH_ZCN_1523H
+ 	bool "Zcomax ZCN-1523H support"
+ 	select SOC_AR724X
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -53,6 +53,7 @@ enum ath79_mach_type {
+ 	ATH79_MACH_HORNET_UB,		/* ALFA Networks Hornet-UB */
+ 	ATH79_MACH_MR600V2,		/* OpenMesh MR600v2 */
+ 	ATH79_MACH_MR600,		/* OpenMesh MR600 */
++	ATH79_MACH_MYNET_N600,		/* WD My Net N600 */
+ 	ATH79_MACH_MZK_W04NU,		/* Planex MZK-W04NU */
+ 	ATH79_MACH_MZK_W300NH,		/* Planex MZK-W300NH */
+ 	ATH79_MACH_NBG460N,		/* Zyxel NBG460N/550N/550NH */
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -64,6 +64,7 @@ obj-$(CONFIG_ATH79_MACH_JA76PF)		+= mach
+ obj-$(CONFIG_ATH79_MACH_JWAP003)	+= mach-jwap003.o
+ obj-$(CONFIG_ATH79_MACH_HORNET_UB)	+= mach-hornet-ub.o
+ obj-$(CONFIG_ATH79_MACH_MR600)		+= mach-mr600.o
++obj-$(CONFIG_ATH79_MACH_MYNET_N600)	+= mach-mynet-n600.o
+ obj-$(CONFIG_ATH79_MACH_MZK_W04NU)	+= mach-mzk-w04nu.o
+ obj-$(CONFIG_ATH79_MACH_MZK_W300NH)	+= mach-mzk-w300nh.o
+ obj-$(CONFIG_ATH79_MACH_NBG460N)	+= mach-nbg460n.o
diff -pruN -x '.*' attitude_adjustment/target/linux/ar71xx/patches-3.3/702-MIPS-ath79-add-MyNet-N750-support.patch attitude_adjustment WD/target/linux/ar71xx/patches-3.3/702-MIPS-ath79-add-MyNet-N750-support.patch
--- attitude_adjustment/target/linux/ar71xx/patches-3.3/702-MIPS-ath79-add-MyNet-N750-support.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/ar71xx/patches-3.3/702-MIPS-ath79-add-MyNet-N750-support.patch	2014-04-20 00:24:00.000000000 -0400
@@ -0,0 +1,39 @@
+--- a/arch/mips/ath79/machtypes.h
++++ b/arch/mips/ath79/machtypes.h
+@@ -47,6 +47,7 @@
+ 	ATH79_MACH_HORNET_UB,		/* ALFA Networks Hornet-UB */
+ 	ATH79_MACH_MR600,		/* OpenMesh MR600 */
+ 	ATH79_MACH_MYNET_N600,		/* WD My Net N600 */
++	ATH79_MACH_MYNET_N750,		/* WD My Net N750 */
+ 	ATH79_MACH_MZK_W04NU,		/* Planex MZK-W04NU */
+ 	ATH79_MACH_MZK_W300NH,		/* Planex MZK-W300NH */
+ 	ATH79_MACH_NBG460N,		/* Zyxel NBG460N/550N/550NH */
+--- a/arch/mips/ath79/Kconfig
++++ b/arch/mips/ath79/Kconfig
+@@ -652,6 +652,16 @@
+ 	select ATH79_DEV_M25P80
+ 	select ATH79_DEV_WMAC
+ 	select ATH79_NVRAM
++	
++config ATH79_MACH_MYNET_N750
++	bool "WD My Net N750 board support"
++	select SOC_AR934X
++	select ATH79_DEV_ETH
++	select ATH79_DEV_GPIO_BUTTONS
++	select ATH79_DEV_LEDS_GPIO
++	select ATH79_DEV_M25P80
++	select ATH79_DEV_WMAC
++	select ATH79_NVRAM
+ 
+ config ATH79_MACH_ZCN_1523H
+ 	bool "Zcomax ZCN-1523H support"
+--- a/arch/mips/ath79/Makefile
++++ b/arch/mips/ath79/Makefile
+@@ -62,6 +62,7 @@
+ obj-$(CONFIG_ATH79_MACH_HORNET_UB)	+= mach-hornet-ub.o
+ obj-$(CONFIG_ATH79_MACH_MR600)		+= mach-mr600.o
+ obj-$(CONFIG_ATH79_MACH_MYNET_N600)	+= mach-mynet-n600.o
++obj-$(CONFIG_ATH79_MACH_MYNET_N750)	+= mach-mynet-n750.o
+ obj-$(CONFIG_ATH79_MACH_MZK_W04NU)	+= mach-mzk-w04nu.o
+ obj-$(CONFIG_ATH79_MACH_MZK_W300NH)	+= mach-mzk-w300nh.o
+ obj-$(CONFIG_ATH79_MACH_NBG460N)	+= mach-nbg460n.o
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/config-3.3 attitude_adjustment WD/target/linux/generic/config-3.3
--- attitude_adjustment/target/linux/generic/config-3.3	2014-04-17 00:00:25.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/config-3.3	2014-04-21 19:48:31.000000000 -0400
@@ -1639,10 +1639,18 @@ CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
 CONFIG_MTD_ROOTFS_ROOT_DEV=y
 CONFIG_MTD_ROOTFS_SPLIT=y
 # CONFIG_MTD_SLRAM is not set
+CONFIG_MTD_SPLIT=y
+# CONFIG_MTD_SPLIT_FIRMWARE is not set
+CONFIG_MTD_SPLIT_FIRMWARE_NAME="firmware"
+# CONFIG_MTD_SPLIT_LZMA_FW is not set
+# CONFIG_MTD_SPLIT_SEAMA_FW is not set
+# CONFIG_MTD_SPLIT_SQUASHFS_ROOT is not set
+# CONFIG_MTD_SPLIT_UIMAGE_FW is not set
 # CONFIG_MTD_SST25L is not set
 # CONFIG_MTD_SWAP is not set
 # CONFIG_MTD_TESTS is not set
 # CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UIMAGE_SPLIT is not set
 # CONFIG_MUTEX_SPIN_ON_OWNER is not set
 # CONFIG_MV643XX_ETH is not set
 # CONFIG_MVSWITCH_PHY is not set
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit.c attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit.c
--- attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit.c	2014-04-18 08:13:06.000000000 -0400
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2009-2013 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2009-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2012 Jonas Gorski <jogo@openwrt.org>
+ * Copyright (C) 2013 Hauke Mehrtens <hauke@hauke-m.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#define pr_fmt(fmt)	"mtdsplit: " fmt
+
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/magic.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/byteorder/generic.h>
+
+#include "mtdsplit.h"
+
+struct squashfs_super_block {
+	__le32 s_magic;
+	__le32 pad0[9];
+	__le64 bytes_used;
+};
+
+int mtd_get_squashfs_len(struct mtd_info *master,
+			 size_t offset,
+			 size_t *squashfs_len)
+{
+	struct squashfs_super_block sb;
+	size_t retlen;
+	int err;
+
+	err = mtd_read(master, offset, sizeof(sb), &retlen, (void *)&sb);
+	if (err || (retlen != sizeof(sb))) {
+		pr_alert("error occured while reading from \"%s\"\n",
+			 master->name);
+		return -EIO;
+	}
+
+	if (le32_to_cpu(sb.s_magic) != SQUASHFS_MAGIC) {
+		pr_alert("no squashfs found in \"%s\"\n", master->name);
+		return -EINVAL;
+	}
+
+	retlen = le64_to_cpu(sb.bytes_used);
+	if (retlen <= 0) {
+		pr_alert("squashfs is empty in \"%s\"\n", master->name);
+		return -ENODEV;
+	}
+
+	if (offset + retlen > master->size) {
+		pr_alert("squashfs has invalid size in \"%s\"\n",
+			 master->name);
+		return -EINVAL;
+	}
+
+	*squashfs_len = retlen;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtd_get_squashfs_len);
+
+static ssize_t mtd_next_eb(struct mtd_info *mtd, size_t offset)
+{
+	return mtd_rounddown_to_eb(offset, mtd) + mtd->erasesize;
+}
+
+int mtd_check_rootfs_magic(struct mtd_info *mtd, size_t offset)
+{
+	u32 magic;
+	size_t retlen;
+	int ret;
+
+	ret = mtd_read(mtd, offset, sizeof(magic), &retlen,
+		       (unsigned char *) &magic);
+	if (ret)
+		return ret;
+
+	if (retlen != sizeof(magic))
+		return -EIO;
+
+	if (le32_to_cpu(magic) != SQUASHFS_MAGIC &&
+	    magic != 0x19852003)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtd_check_rootfs_magic);
+
+int mtd_find_rootfs_from(struct mtd_info *mtd,
+			 size_t from,
+			 size_t limit,
+			 size_t *ret_offset)
+{
+	size_t offset;
+	int err;
+
+	for (offset = from; offset < limit;
+	     offset = mtd_next_eb(mtd, offset)) {
+		err = mtd_check_rootfs_magic(mtd, offset);
+		if (err)
+			continue;
+
+		*ret_offset = offset;
+		return 0;
+	}
+
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(mtd_find_rootfs_from);
+
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit.h attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit.h
--- attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit.h	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit.h	2014-04-18 08:13:06.000000000 -0400
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2009-2013 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2009-2013 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (C) 2012 Jonas Gorski <jogo@openwrt.org>
+ * Copyright (C) 2013 Hauke Mehrtens <hauke@hauke-m.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#ifndef _MTDSPLIT_H
+#define _MTDSPLIT_H
+
+#define KERNEL_PART_NAME	"kernel"
+#define ROOTFS_PART_NAME	"rootfs"
+
+#define ROOTFS_SPLIT_NAME	"rootfs_data"
+
+#ifdef CONFIG_MTD_SPLIT
+int mtd_get_squashfs_len(struct mtd_info *master,
+			 size_t offset,
+			 size_t *squashfs_len);
+
+int mtd_check_rootfs_magic(struct mtd_info *mtd, size_t offset);
+
+int mtd_find_rootfs_from(struct mtd_info *mtd,
+			 size_t from,
+			 size_t limit,
+			 size_t *ret_offset);
+
+#else
+static inline int mtd_get_squashfs_len(struct mtd_info *master,
+				       size_t offset,
+				       size_t *squashfs_len)
+{
+	return -ENODEV;
+}
+
+static inline int mtd_check_rootfs_magic(struct mtd_info *mtd, size_t offset)
+{
+	return -EINVAL;
+}
+
+static inline int mtd_find_rootfs_from(struct mtd_info *mtd,
+				       size_t from,
+				       size_t limit,
+				       size_t *ret_offset)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_MTD_SPLIT */
+
+#endif /* _MTDSPLIT_H */
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_lzma.c attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_lzma.c
--- attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_lzma.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_lzma.c	2014-04-18 08:13:06.000000000 -0400
@@ -0,0 +1,96 @@
+/*
+ *  Copyright (C) 2014 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/unaligned.h>
+
+#include "mtdsplit.h"
+
+#define LZMA_NR_PARTS		2
+#define LZMA_PROPERTIES_SIZE	5
+
+struct lzma_header {
+	u8 props[LZMA_PROPERTIES_SIZE];
+	u8 size_low[4];
+	u8 size_high[4];
+};
+
+static int mtdsplit_parse_lzma(struct mtd_info *master,
+			       struct mtd_partition **pparts,
+			       struct mtd_part_parser_data *data)
+{
+	struct lzma_header hdr;
+	size_t hdr_len, retlen;
+	size_t rootfs_offset;
+	u32 t;
+	struct mtd_partition *parts;
+	int err;
+
+	hdr_len = sizeof(hdr);
+	err = mtd_read(master, 0, hdr_len, &retlen, (void *) &hdr);
+	if (err)
+		return err;
+
+	if (retlen != hdr_len)
+		return -EIO;
+
+	/* verify LZMA properties */
+	if (hdr.props[0] >= (9 * 5 * 5))
+		return -EINVAL;
+
+	t = get_unaligned_le32(&hdr.props[1]);
+	if (!is_power_of_2(t))
+		return -EINVAL;
+
+	t = get_unaligned_le32(&hdr.size_high);
+	if (t)
+		return -EINVAL;
+
+	err = mtd_find_rootfs_from(master, master->erasesize,
+				   master->size, &rootfs_offset);
+	if (err)
+		return err;
+
+	parts = kzalloc(LZMA_NR_PARTS * sizeof(*parts), GFP_KERNEL);
+	if (!parts)
+		return -ENOMEM;
+
+	parts[0].name = KERNEL_PART_NAME;
+	parts[0].offset = 0;
+	parts[0].size = rootfs_offset;
+
+	parts[1].name = ROOTFS_PART_NAME;
+	parts[1].offset = rootfs_offset;
+	parts[1].size = master->size - rootfs_offset;
+
+	*pparts = parts;
+	return LZMA_NR_PARTS;
+}
+
+static struct mtd_part_parser mtdsplit_lzma_parser = {
+	.owner = THIS_MODULE,
+	.name = "lzma-fw",
+	.parse_fn = mtdsplit_parse_lzma,
+	.type = MTD_PARSER_TYPE_FIRMWARE,
+};
+
+static int __init mtdsplit_lzma_init(void)
+{
+	register_mtd_parser(&mtdsplit_lzma_parser);
+
+	return 0;
+}
+
+subsys_initcall(mtdsplit_lzma_init);
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_seama.c attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_seama.c
--- attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_seama.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_seama.c	2014-04-18 08:13:06.000000000 -0400
@@ -0,0 +1,103 @@
+/*
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/byteorder/generic.h>
+
+#include "mtdsplit.h"
+
+#define SEAMA_MAGIC		0x5EA3A417
+#define SEAMA_NR_PARTS		2
+#define SEAMA_MIN_ROOTFS_OFFS	0x80000	/* 512KiB */
+
+struct seama_header {
+	__be32	magic;		/* should always be SEAMA_MAGIC. */
+	__be16	reserved;	/* reserved for  */
+	__be16	metasize;	/* size of the META data */
+	__be32	size;		/* size of the image */
+};
+
+static int mtdsplit_parse_seama(struct mtd_info *master,
+				struct mtd_partition **pparts,
+				struct mtd_part_parser_data *data)
+{
+	struct seama_header hdr;
+	size_t hdr_len, retlen, kernel_size;
+	size_t rootfs_offset;
+	struct mtd_partition *parts;
+	int err;
+
+	hdr_len = sizeof(hdr);
+	err = mtd_read(master, 0, hdr_len, &retlen, (void *) &hdr);
+	if (err)
+		return err;
+
+	if (retlen != hdr_len)
+		return -EIO;
+
+	/* sanity checks */
+	if (be32_to_cpu(hdr.magic) != SEAMA_MAGIC)
+		return -EINVAL;
+
+	kernel_size = hdr_len + be32_to_cpu(hdr.size) +
+		      be16_to_cpu(hdr.metasize);
+	if (kernel_size > master->size)
+		return -EINVAL;
+
+	/* Find the rootfs after the kernel. */
+	err = mtd_check_rootfs_magic(master, kernel_size);
+	if (!err) {
+		rootfs_offset = kernel_size;
+	} else {
+		/*
+		 * The size in the header might cover the rootfs as well.
+		 * Start the search from an arbitrary offset.
+		 */
+		err = mtd_find_rootfs_from(master, SEAMA_MIN_ROOTFS_OFFS,
+					   master->size, &rootfs_offset);
+		if (err)
+			return err;
+	}
+
+	parts = kzalloc(SEAMA_NR_PARTS * sizeof(*parts), GFP_KERNEL);
+	if (!parts)
+		return -ENOMEM;
+
+	parts[0].name = KERNEL_PART_NAME;
+	parts[0].offset = 0;
+	parts[0].size = rootfs_offset;
+
+	parts[1].name = ROOTFS_PART_NAME;
+	parts[1].offset = rootfs_offset;
+	parts[1].size = master->size - rootfs_offset;
+
+	*pparts = parts;
+	return SEAMA_NR_PARTS;
+}
+
+static struct mtd_part_parser mtdsplit_seama_parser = {
+	.owner = THIS_MODULE,
+	.name = "seama-fw",
+	.parse_fn = mtdsplit_parse_seama,
+	.type = MTD_PARSER_TYPE_FIRMWARE,
+};
+
+static int __init mtdsplit_seama_init(void)
+{
+	register_mtd_parser(&mtdsplit_seama_parser);
+
+	return 0;
+}
+
+subsys_initcall(mtdsplit_seama_init);
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_squashfs.c attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_squashfs.c
--- attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_squashfs.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_squashfs.c	2014-04-18 08:13:06.000000000 -0400
@@ -0,0 +1,72 @@
+/*
+ *  Copyright (C) 2013 Felix Fietkau <nbd@openwrt.org>
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/magic.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/byteorder/generic.h>
+
+#include "mtdsplit.h"
+
+static int
+mtdsplit_parse_squashfs(struct mtd_info *master,
+			struct mtd_partition **pparts,
+			struct mtd_part_parser_data *data)
+{
+	struct mtd_partition *part;
+	struct mtd_info *parent_mtd;
+	size_t part_offset;
+	size_t squashfs_len;
+	int err;
+
+	err = mtd_get_squashfs_len(master, 0, &squashfs_len);
+	if (err)
+		return err;
+
+	parent_mtd = mtdpart_get_master(master);
+	part_offset = mtdpart_get_offset(master);
+
+	part = kzalloc(sizeof(*part), GFP_KERNEL);
+	if (!part) {
+		pr_alert("unable to allocate memory for \"%s\" partition\n",
+			 ROOTFS_SPLIT_NAME);
+		return -ENOMEM;
+	}
+
+	part->name = ROOTFS_SPLIT_NAME;
+	part->offset = mtd_roundup_to_eb(part_offset + squashfs_len,
+					 parent_mtd) - part_offset;
+	part->size = master->size - part->offset;
+
+	*pparts = part;
+	return 1;
+}
+
+static struct mtd_part_parser mtdsplit_squashfs_parser = {
+	.owner = THIS_MODULE,
+	.name = "squashfs-split",
+	.parse_fn = mtdsplit_parse_squashfs,
+	.type = MTD_PARSER_TYPE_ROOTFS,
+};
+
+static int __init mtdsplit_squashfs_init(void)
+{
+	register_mtd_parser(&mtdsplit_squashfs_parser);
+
+	return 0;
+}
+
+subsys_initcall(mtdsplit_squashfs_init);
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_uimage.c attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_uimage.c
--- attitude_adjustment/target/linux/generic/files/drivers/mtd/mtdsplit_uimage.c	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/files/drivers/mtd/mtdsplit_uimage.c	2014-04-18 08:13:06.000000000 -0400
@@ -0,0 +1,282 @@
+/*
+ *  Copyright (C) 2013 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/byteorder/generic.h>
+
+#include "mtdsplit.h"
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number		*/
+#define IH_NMLEN		32	/* Image Name Length		*/
+
+#define IH_OS_LINUX		5	/* Linux	*/
+
+#define IH_TYPE_KERNEL		2	/* OS Kernel Image		*/
+#define IH_TYPE_FILESYSTEM	7	/* Filesystem Image		*/
+
+/*
+ * Legacy format image header,
+ * all data in network byte order (aka natural aka bigendian).
+ */
+struct uimage_header {
+	uint32_t	ih_magic;	/* Image Header Magic Number	*/
+	uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/
+	uint32_t	ih_time;	/* Image Creation Timestamp	*/
+	uint32_t	ih_size;	/* Image Data Size		*/
+	uint32_t	ih_load;	/* Data	 Load  Address		*/
+	uint32_t	ih_ep;		/* Entry Point Address		*/
+	uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/
+	uint8_t		ih_os;		/* Operating System		*/
+	uint8_t		ih_arch;	/* CPU architecture		*/
+	uint8_t		ih_type;	/* Image Type			*/
+	uint8_t		ih_comp;	/* Compression Type		*/
+	uint8_t		ih_name[IH_NMLEN];	/* Image Name		*/
+};
+
+static int
+read_uimage_header(struct mtd_info *mtd, size_t offset,
+		   struct uimage_header *header)
+{
+	size_t header_len;
+	size_t retlen;
+	int ret;
+
+	header_len = sizeof(*header);
+	ret = mtd_read(mtd, offset, header_len, &retlen,
+		       (unsigned char *) header);
+	if (ret) {
+		pr_debug("read error in \"%s\"\n", mtd->name);
+		return ret;
+	}
+
+	if (retlen != header_len) {
+		pr_debug("short read in \"%s\"\n", mtd->name);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int __mtdsplit_parse_uimage(struct mtd_info *master,
+				   struct mtd_partition **pparts,
+				   struct mtd_part_parser_data *data,
+				   bool (*verify)(struct uimage_header *hdr))
+{
+	struct mtd_partition *parts;
+	struct uimage_header *header;
+	int nr_parts;
+	size_t offset;
+	size_t uimage_offset;
+	size_t uimage_size = 0;
+	size_t rootfs_offset;
+	size_t rootfs_size = 0;
+	int uimage_part, rf_part;
+	int ret;
+
+	nr_parts = 2;
+	parts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);
+	if (!parts)
+		return -ENOMEM;
+
+	header = vmalloc(sizeof(*header));
+	if (!header) {
+		ret = -ENOMEM;
+		goto err_free_parts;
+	}
+
+	/* find uImage on erase block boundaries */
+	for (offset = 0; offset < master->size; offset += master->erasesize) {
+		uimage_size = 0;
+
+		ret = read_uimage_header(master, offset, header);
+		if (ret)
+			continue;
+
+		if (!verify(header)) {
+			pr_debug("no valid uImage found in \"%s\" at offset %llx\n",
+				 master->name, (unsigned long long) offset);
+			continue;
+		}
+
+		uimage_size = sizeof(*header) + be32_to_cpu(header->ih_size);
+		if ((offset + uimage_size) > master->size) {
+			pr_debug("uImage exceeds MTD device \"%s\"\n",
+				 master->name);
+			continue;
+		}
+		break;
+	}
+
+	if (uimage_size == 0) {
+		pr_debug("no uImage found in \"%s\"\n", master->name);
+		ret = -ENODEV;
+		goto err_free_header;
+	}
+
+	uimage_offset = offset;
+
+	if (uimage_offset == 0) {
+		uimage_part = 0;
+		rf_part = 1;
+
+		/* find the roots after the uImage */
+		ret = mtd_find_rootfs_from(master,
+					   uimage_offset + uimage_size,
+					   master->size,
+					   &rootfs_offset);
+		if (ret) {
+			pr_debug("no rootfs after uImage in \"%s\"\n",
+				 master->name);
+			goto err_free_header;
+		}
+
+		rootfs_size = master->size - rootfs_offset;
+		uimage_size = rootfs_offset - uimage_offset;
+	} else {
+		rf_part = 0;
+		uimage_part = 1;
+
+		/* check rootfs presence at offset 0 */
+		ret = mtd_check_rootfs_magic(master, 0);
+		if (ret) {
+			pr_debug("no rootfs before uImage in \"%s\"\n",
+				 master->name);
+			goto err_free_header;
+		}
+
+		rootfs_offset = 0;
+		rootfs_size = uimage_offset;
+	}
+
+	if (rootfs_size == 0) {
+		pr_debug("no rootfs found in \"%s\"\n", master->name);
+		ret = -ENODEV;
+		goto err_free_header;
+	}
+
+	parts[uimage_part].name = KERNEL_PART_NAME;
+	parts[uimage_part].offset = uimage_offset;
+	parts[uimage_part].size = uimage_size;
+
+	parts[rf_part].name = ROOTFS_PART_NAME;
+	parts[rf_part].offset = rootfs_offset;
+	parts[rf_part].size = rootfs_size;
+
+	vfree(header);
+
+	*pparts = parts;
+	return nr_parts;
+
+err_free_header:
+	vfree(header);
+
+err_free_parts:
+	kfree(parts);
+	return ret;
+}
+
+static bool uimage_verify_default(struct uimage_header *header)
+{
+	/* default sanity checks */
+	if (be32_to_cpu(header->ih_magic) != IH_MAGIC) {
+		pr_debug("invalid uImage magic: %08x\n",
+			 be32_to_cpu(header->ih_magic));
+		return false;
+	}
+
+	if (header->ih_os != IH_OS_LINUX) {
+		pr_debug("invalid uImage OS: %08x\n",
+			 be32_to_cpu(header->ih_os));
+		return false;
+	}
+
+	if (header->ih_type != IH_TYPE_KERNEL) {
+		pr_debug("invalid uImage type: %08x\n",
+			 be32_to_cpu(header->ih_type));
+		return false;
+	}
+
+	return true;
+}
+
+static int
+mtdsplit_uimage_parse_generic(struct mtd_info *master,
+			      struct mtd_partition **pparts,
+			      struct mtd_part_parser_data *data)
+{
+	return __mtdsplit_parse_uimage(master, pparts, data,
+				      uimage_verify_default);
+}
+
+static struct mtd_part_parser uimage_generic_parser = {
+	.owner = THIS_MODULE,
+	.name = "uimage-fw",
+	.parse_fn = mtdsplit_uimage_parse_generic,
+	.type = MTD_PARSER_TYPE_FIRMWARE,
+};
+
+#define FW_MAGIC_WNR2000V3	0x32303033
+#define FW_MAGIC_WNR2200	0x32323030
+#define FW_MAGIC_WNR612V2	0x32303631
+#define FW_MAGIC_WNDR3700	0x33373030
+#define FW_MAGIC_WNDR3700V2	0x33373031
+
+static bool uimage_verify_wndr3700(struct uimage_header *header)
+{
+	switch be32_to_cpu(header->ih_magic) {
+	case FW_MAGIC_WNR612V2:
+	case FW_MAGIC_WNR2000V3:
+	case FW_MAGIC_WNR2200:
+	case FW_MAGIC_WNDR3700:
+	case FW_MAGIC_WNDR3700V2:
+		break;
+	default:
+		return false;
+	}
+
+	if (header->ih_os != IH_OS_LINUX ||
+	    header->ih_type != IH_TYPE_FILESYSTEM)
+		return false;
+
+	return true;
+}
+
+static int
+mtdsplit_uimage_parse_netgear(struct mtd_info *master,
+			      struct mtd_partition **pparts,
+			      struct mtd_part_parser_data *data)
+{
+	return __mtdsplit_parse_uimage(master, pparts, data,
+				      uimage_verify_wndr3700);
+}
+
+static struct mtd_part_parser uimage_netgear_parser = {
+	.owner = THIS_MODULE,
+	.name = "netgear-fw",
+	.parse_fn = mtdsplit_uimage_parse_netgear,
+	.type = MTD_PARSER_TYPE_FIRMWARE,
+};
+
+static int __init mtdsplit_uimage_init(void)
+{
+	register_mtd_parser(&uimage_generic_parser);
+	register_mtd_parser(&uimage_netgear_parser);
+
+	return 0;
+}
+
+module_init(mtdsplit_uimage_init);
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/mtd/myloader.c attitude_adjustment WD/target/linux/generic/files/drivers/mtd/myloader.c
--- attitude_adjustment/target/linux/generic/files/drivers/mtd/myloader.c	2014-04-16 23:59:59.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/files/drivers/mtd/myloader.c	2014-04-18 08:13:06.000000000 -0400
@@ -32,15 +32,9 @@ struct part_data {
 	char names[MYLO_MAX_PARTITIONS][PART_NAME_LEN];
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 static int myloader_parse_partitions(struct mtd_info *master,
 				     struct mtd_partition **pparts,
 				     struct mtd_part_parser_data *data)
-#else
-static int myloader_parse_partitions(struct mtd_info *master,
-				     struct mtd_partition **pparts,
-				     unsigned long origin)
-#endif
 {
 	struct part_data *buf;
 	struct mylo_partition_table *tab;
@@ -170,7 +164,9 @@ static struct mtd_part_parser myloader_m
 
 static int __init myloader_mtd_parser_init(void)
 {
-	return register_mtd_parser(&myloader_mtd_parser);
+	register_mtd_parser(&myloader_mtd_parser);
+
+	return 0;
 }
 
 static void __exit myloader_mtd_parser_exit(void)
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/net/phy/ar8216.c attitude_adjustment WD/target/linux/generic/files/drivers/net/phy/ar8216.c
--- attitude_adjustment/target/linux/generic/files/drivers/net/phy/ar8216.c	2014-04-17 00:00:00.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/files/drivers/net/phy/ar8216.c	2014-04-18 08:13:06.000000000 -0400
@@ -33,6 +33,10 @@
 #include <linux/lockdep.h>
 #include <linux/ar8216_platform.h>
 #include <linux/workqueue.h>
+#include <linux/of_device.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+
 #include "ar8216.h"
 
 /* size of the vlan table */
@@ -42,7 +46,7 @@
 
 #define AR8XXX_MIB_WORK_DELAY	2000 /* msecs */
 
-struct ar8216_priv;
+struct ar8xxx_priv;
 
 #define AR8XXX_CAP_GIGE			BIT(0)
 #define AR8XXX_CAP_MIB_COUNTERS		BIT(1)
@@ -52,6 +56,7 @@ enum {
 	AR8XXX_VER_AR8236 = 0x03,
 	AR8XXX_VER_AR8316 = 0x10,
 	AR8XXX_VER_AR8327 = 0x12,
+	AR8XXX_VER_AR8337 = 0x13,
 };
 
 struct ar8xxx_mib_desc {
@@ -63,31 +68,78 @@ struct ar8xxx_mib_desc {
 struct ar8xxx_chip {
 	unsigned long caps;
 
-	int (*hw_init)(struct ar8216_priv *priv);
-	void (*init_globals)(struct ar8216_priv *priv);
-	void (*init_port)(struct ar8216_priv *priv, int port);
-	void (*setup_port)(struct ar8216_priv *priv, int port, u32 egress,
+	int (*hw_init)(struct ar8xxx_priv *priv);
+	void (*cleanup)(struct ar8xxx_priv *priv);
+
+	void (*init_globals)(struct ar8xxx_priv *priv);
+	void (*init_port)(struct ar8xxx_priv *priv, int port);
+	void (*setup_port)(struct ar8xxx_priv *priv, int port, u32 egress,
 			   u32 ingress, u32 members, u32 pvid);
-	u32 (*read_port_status)(struct ar8216_priv *priv, int port);
-	int (*atu_flush)(struct ar8216_priv *priv);
-	void (*vtu_flush)(struct ar8216_priv *priv);
-	void (*vtu_load_vlan)(struct ar8216_priv *priv, u32 vid, u32 port_mask);
+	u32 (*read_port_status)(struct ar8xxx_priv *priv, int port);
+	int (*atu_flush)(struct ar8xxx_priv *priv);
+	void (*vtu_flush)(struct ar8xxx_priv *priv);
+	void (*vtu_load_vlan)(struct ar8xxx_priv *priv, u32 vid, u32 port_mask);
 
 	const struct ar8xxx_mib_desc *mib_decs;
 	unsigned num_mibs;
 };
 
-struct ar8216_priv {
+enum ar8327_led_pattern {
+	AR8327_LED_PATTERN_OFF = 0,
+	AR8327_LED_PATTERN_BLINK,
+	AR8327_LED_PATTERN_ON,
+	AR8327_LED_PATTERN_RULE,
+};
+
+struct ar8327_led_entry {
+	unsigned reg;
+	unsigned shift;
+};
+
+struct ar8327_led {
+	struct led_classdev cdev;
+	struct ar8xxx_priv *sw_priv;
+
+	char *name;
+	bool active_low;
+	u8 led_num;
+	enum ar8327_led_mode mode;
+
+	struct mutex mutex;
+	spinlock_t lock;
+	struct work_struct led_work;
+	bool enable_hw_mode;
+	enum ar8327_led_pattern pattern;
+};
+
+struct ar8327_data {
+	u32 port0_status;
+	u32 port6_status;
+
+	struct ar8327_led **leds;
+	unsigned int num_leds;
+};
+
+struct ar8xxx_priv {
 	struct switch_dev dev;
+	struct mii_bus *mii_bus;
 	struct phy_device *phy;
-	u32 (*read)(struct ar8216_priv *priv, int reg);
-	void (*write)(struct ar8216_priv *priv, int reg, u32 val);
+
+	u32 (*read)(struct ar8xxx_priv *priv, int reg);
+	void (*write)(struct ar8xxx_priv *priv, int reg, u32 val);
+	u32 (*rmw)(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val);
+
+	int (*get_port_link)(unsigned port);
+
 	const struct net_device_ops *ndo_old;
 	struct net_device_ops ndo;
 	struct mutex reg_mutex;
 	u8 chip_ver;
 	u8 chip_rev;
 	const struct ar8xxx_chip *chip;
+	union {
+		struct ar8327_data ar8327;
+	} chip_data;
 	bool initialized;
 	bool port4_phy;
 	char buf[2048];
@@ -100,12 +152,21 @@ struct ar8216_priv {
 	int mib_next_port;
 	u64 *mib_stats;
 
+	struct list_head list;
+	unsigned int use_count;
+
 	/* all fields below are cleared on reset */
 	bool vlan;
 	u16 vlan_id[AR8X16_MAX_VLANS];
 	u8 vlan_table[AR8X16_MAX_VLANS];
 	u8 vlan_tagged;
 	u16 pvid[AR8X16_MAX_PORTS];
+
+	/* mirroring */
+	bool mirror_rx;
+	bool mirror_tx;
+	int source_port;
+	int monitor_port;
 };
 
 #define MIB_DESC(_s , _o, _n)	\
@@ -197,38 +258,50 @@ static const struct ar8xxx_mib_desc ar82
 	MIB_DESC(1, AR8236_STATS_TXLATECOL, "TxLateCol"),
 };
 
-#define to_ar8216(_dev) container_of(_dev, struct ar8216_priv, dev)
+static DEFINE_MUTEX(ar8xxx_dev_list_lock);
+static LIST_HEAD(ar8xxx_dev_list);
 
-static inline bool ar8xxx_has_gige(struct ar8216_priv *priv)
+static inline struct ar8xxx_priv *
+swdev_to_ar8xxx(struct switch_dev *swdev)
+{
+	return container_of(swdev, struct ar8xxx_priv, dev);
+}
+
+static inline bool ar8xxx_has_gige(struct ar8xxx_priv *priv)
 {
 	return priv->chip->caps & AR8XXX_CAP_GIGE;
 }
 
-static inline bool ar8xxx_has_mib_counters(struct ar8216_priv *priv)
+static inline bool ar8xxx_has_mib_counters(struct ar8xxx_priv *priv)
 {
 	return priv->chip->caps & AR8XXX_CAP_MIB_COUNTERS;
 }
 
-static inline bool chip_is_ar8216(struct ar8216_priv *priv)
+static inline bool chip_is_ar8216(struct ar8xxx_priv *priv)
 {
 	return priv->chip_ver == AR8XXX_VER_AR8216;
 }
 
-static inline bool chip_is_ar8236(struct ar8216_priv *priv)
+static inline bool chip_is_ar8236(struct ar8xxx_priv *priv)
 {
 	return priv->chip_ver == AR8XXX_VER_AR8236;
 }
 
-static inline bool chip_is_ar8316(struct ar8216_priv *priv)
+static inline bool chip_is_ar8316(struct ar8xxx_priv *priv)
 {
 	return priv->chip_ver == AR8XXX_VER_AR8316;
 }
 
-static inline bool chip_is_ar8327(struct ar8216_priv *priv)
+static inline bool chip_is_ar8327(struct ar8xxx_priv *priv)
 {
 	return priv->chip_ver == AR8XXX_VER_AR8327;
 }
 
+static inline bool chip_is_ar8337(struct ar8xxx_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8337;
+}
+
 static inline void
 split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
 {
@@ -243,10 +316,9 @@ split_addr(u32 regaddr, u16 *r1, u16 *r2
 }
 
 static u32
-ar8216_mii_read(struct ar8216_priv *priv, int reg)
+ar8xxx_mii_read(struct ar8xxx_priv *priv, int reg)
 {
-	struct phy_device *phy = priv->phy;
-	struct mii_bus *bus = phy->bus;
+	struct mii_bus *bus = priv->mii_bus;
 	u16 r1, r2, page;
 	u16 lo, hi;
 
@@ -265,10 +337,9 @@ ar8216_mii_read(struct ar8216_priv *priv
 }
 
 static void
-ar8216_mii_write(struct ar8216_priv *priv, int reg, u32 val)
+ar8xxx_mii_write(struct ar8xxx_priv *priv, int reg, u32 val)
 {
-	struct phy_device *phy = priv->phy;
-	struct mii_bus *bus = phy->bus;
+	struct mii_bus *bus = priv->mii_bus;
 	u16 r1, r2, r3;
 	u16 lo, hi;
 
@@ -291,11 +362,50 @@ ar8216_mii_write(struct ar8216_priv *pri
 	mutex_unlock(&bus->mdio_lock);
 }
 
+static u32
+ar8xxx_mii_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
+{
+	struct mii_bus *bus = priv->mii_bus;
+	u16 r1, r2, page;
+	u16 lo, hi;
+	u32 ret;
+
+	split_addr((u32) reg, &r1, &r2, &page);
+
+	mutex_lock(&bus->mdio_lock);
+
+	bus->write(bus, 0x18, 0, page);
+	usleep_range(1000, 2000); /* wait for the page switch to propagate */
+
+	lo = bus->read(bus, 0x10 | r2, r1);
+	hi = bus->read(bus, 0x10 | r2, r1 + 1);
+
+	ret = hi << 16 | lo;
+	ret &= ~mask;
+	ret |= val;
+
+	lo = ret & 0xffff;
+	hi = (u16) (ret >> 16);
+
+	if (priv->mii_lo_first) {
+		bus->write(bus, 0x10 | r2, r1, lo);
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+	} else {
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+		bus->write(bus, 0x10 | r2, r1, lo);
+	}
+
+	mutex_unlock(&bus->mdio_lock);
+
+	return ret;
+}
+
+
 static void
-ar8216_phy_dbg_write(struct ar8216_priv *priv, int phy_addr,
+ar8xxx_phy_dbg_write(struct ar8xxx_priv *priv, int phy_addr,
 		     u16 dbg_addr, u16 dbg_data)
 {
-	struct mii_bus *bus = priv->phy->bus;
+	struct mii_bus *bus = priv->mii_bus;
 
 	mutex_lock(&bus->mdio_lock);
 	bus->write(bus, phy_addr, MII_ATH_DBG_ADDR, dbg_addr);
@@ -304,9 +414,9 @@ ar8216_phy_dbg_write(struct ar8216_priv 
 }
 
 static void
-ar8216_phy_mmd_write(struct ar8216_priv *priv, int phy_addr, u16 addr, u16 data)
+ar8xxx_phy_mmd_write(struct ar8xxx_priv *priv, int phy_addr, u16 addr, u16 data)
 {
-	struct mii_bus *bus = priv->phy->bus;
+	struct mii_bus *bus = priv->mii_bus;
 
 	mutex_lock(&bus->mdio_lock);
 	bus->write(bus, phy_addr, MII_ATH_MMD_ADDR, addr);
@@ -314,35 +424,20 @@ ar8216_phy_mmd_write(struct ar8216_priv 
 	mutex_unlock(&bus->mdio_lock);
 }
 
-static u32
-ar8216_rmw(struct ar8216_priv *priv, int reg, u32 mask, u32 val)
+static inline u32
+ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 {
-	u32 v;
-
-	lockdep_assert_held(&priv->reg_mutex);
-
-	v = priv->read(priv, reg);
-	v &= ~mask;
-	v |= val;
-	priv->write(priv, reg, v);
-
-	return v;
+	return priv->rmw(priv, reg, mask, val);
 }
 
 static inline void
-ar8216_reg_set(struct ar8216_priv *priv, int reg, u32 val)
+ar8xxx_reg_set(struct ar8xxx_priv *priv, int reg, u32 val)
 {
-	u32 v;
-
-	lockdep_assert_held(&priv->reg_mutex);
-
-	v = priv->read(priv, reg);
-	v |= val;
-	priv->write(priv, reg, v);
+	priv->rmw(priv, reg, 0, val);
 }
 
 static int
-ar8216_reg_wait(struct ar8216_priv *priv, u32 reg, u32 mask, u32 val,
+ar8xxx_reg_wait(struct ar8xxx_priv *priv, u32 reg, u32 mask, u32 val,
 		unsigned timeout)
 {
 	int i;
@@ -361,25 +456,23 @@ ar8216_reg_wait(struct ar8216_priv *priv
 }
 
 static int
-ar8216_mib_op(struct ar8216_priv *priv, u32 op)
+ar8xxx_mib_op(struct ar8xxx_priv *priv, u32 op)
 {
 	unsigned mib_func;
 	int ret;
 
 	lockdep_assert_held(&priv->mib_lock);
 
-	if (chip_is_ar8327(priv))
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv))
 		mib_func = AR8327_REG_MIB_FUNC;
 	else
 		mib_func = AR8216_REG_MIB_FUNC;
 
-	mutex_lock(&priv->reg_mutex);
 	/* Capture the hardware statistics for all ports */
-	ar8216_rmw(priv, mib_func, AR8216_MIB_FUNC, (op << AR8216_MIB_FUNC_S));
-	mutex_unlock(&priv->reg_mutex);
+	ar8xxx_rmw(priv, mib_func, AR8216_MIB_FUNC, (op << AR8216_MIB_FUNC_S));
 
 	/* Wait for the capturing to complete. */
-	ret = ar8216_reg_wait(priv, mib_func, AR8216_MIB_BUSY, 0, 10);
+	ret = ar8xxx_reg_wait(priv, mib_func, AR8216_MIB_BUSY, 0, 10);
 	if (ret)
 		goto out;
 
@@ -390,19 +483,19 @@ out:
 }
 
 static int
-ar8216_mib_capture(struct ar8216_priv *priv)
+ar8xxx_mib_capture(struct ar8xxx_priv *priv)
 {
-	return ar8216_mib_op(priv, AR8216_MIB_FUNC_CAPTURE);
+	return ar8xxx_mib_op(priv, AR8216_MIB_FUNC_CAPTURE);
 }
 
 static int
-ar8216_mib_flush(struct ar8216_priv *priv)
+ar8xxx_mib_flush(struct ar8xxx_priv *priv)
 {
-	return ar8216_mib_op(priv, AR8216_MIB_FUNC_FLUSH);
+	return ar8xxx_mib_op(priv, AR8216_MIB_FUNC_FLUSH);
 }
 
 static void
-ar8216_mib_fetch_port_stat(struct ar8216_priv *priv, int port, bool flush)
+ar8xxx_mib_fetch_port_stat(struct ar8xxx_priv *priv, int port, bool flush)
 {
 	unsigned int base;
 	u64 *mib_stats;
@@ -412,7 +505,7 @@ ar8216_mib_fetch_port_stat(struct ar8216
 
 	lockdep_assert_held(&priv->mib_lock);
 
-	if (chip_is_ar8327(priv))
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv))
 		base = AR8327_REG_PORT_STATS_BASE(port);
 	else if (chip_is_ar8236(priv) ||
 		 chip_is_ar8316(priv))
@@ -442,7 +535,7 @@ ar8216_mib_fetch_port_stat(struct ar8216
 }
 
 static void
-ar8216_read_port_link(struct ar8216_priv *priv, int port,
+ar8216_read_port_link(struct ar8xxx_priv *priv, int port,
 		      struct switch_port_link *link)
 {
 	u32 status;
@@ -455,12 +548,21 @@ ar8216_read_port_link(struct ar8216_priv
 	link->aneg = !!(status & AR8216_PORT_STATUS_LINK_AUTO);
 	if (link->aneg) {
 		link->link = !!(status & AR8216_PORT_STATUS_LINK_UP);
-		if (!link->link)
-			return;
 	} else {
 		link->link = true;
+
+		if (priv->get_port_link) {
+			int err;
+
+			err = priv->get_port_link(port);
+			if (err >= 0)
+				link->link = !!err;
+		}
 	}
 
+	if (!link->link)
+		return;
+
 	link->duplex = !!(status & AR8216_PORT_STATUS_DUPLEX);
 	link->tx_flow = !!(status & AR8216_PORT_STATUS_TXFLOW);
 	link->rx_flow = !!(status & AR8216_PORT_STATUS_RXFLOW);
@@ -487,7 +589,7 @@ ar8216_read_port_link(struct ar8216_priv
 static struct sk_buff *
 ar8216_mangle_tx(struct net_device *dev, struct sk_buff *skb)
 {
-	struct ar8216_priv *priv = dev->phy_ptr;
+	struct ar8xxx_priv *priv = dev->phy_ptr;
 	unsigned char *buf;
 
 	if (unlikely(!priv))
@@ -516,7 +618,7 @@ error:
 static void
 ar8216_mangle_rx(struct net_device *dev, struct sk_buff *skb)
 {
-	struct ar8216_priv *priv;
+	struct ar8xxx_priv *priv;
 	unsigned char *buf;
 	int port, vlan;
 
@@ -551,7 +653,7 @@ ar8216_mangle_rx(struct net_device *dev,
 }
 
 static int
-ar8216_wait_bit(struct ar8216_priv *priv, int reg, u32 mask, u32 val)
+ar8216_wait_bit(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 {
 	int timeout = 20;
 	u32 t = 0;
@@ -573,7 +675,7 @@ ar8216_wait_bit(struct ar8216_priv *priv
 }
 
 static void
-ar8216_vtu_op(struct ar8216_priv *priv, u32 op, u32 val)
+ar8216_vtu_op(struct ar8xxx_priv *priv, u32 op, u32 val)
 {
 	if (ar8216_wait_bit(priv, AR8216_REG_VTU, AR8216_VTU_ACTIVE, 0))
 		return;
@@ -587,13 +689,13 @@ ar8216_vtu_op(struct ar8216_priv *priv, 
 }
 
 static void
-ar8216_vtu_flush(struct ar8216_priv *priv)
+ar8216_vtu_flush(struct ar8xxx_priv *priv)
 {
 	ar8216_vtu_op(priv, AR8216_VTU_OP_FLUSH, 0);
 }
 
 static void
-ar8216_vtu_load_vlan(struct ar8216_priv *priv, u32 vid, u32 port_mask)
+ar8216_vtu_load_vlan(struct ar8xxx_priv *priv, u32 vid, u32 port_mask)
 {
 	u32 op;
 
@@ -602,7 +704,7 @@ ar8216_vtu_load_vlan(struct ar8216_priv 
 }
 
 static int
-ar8216_atu_flush(struct ar8216_priv *priv)
+ar8216_atu_flush(struct ar8xxx_priv *priv)
 {
 	int ret;
 
@@ -614,13 +716,13 @@ ar8216_atu_flush(struct ar8216_priv *pri
 }
 
 static u32
-ar8216_read_port_status(struct ar8216_priv *priv, int port)
+ar8216_read_port_status(struct ar8xxx_priv *priv, int port)
 {
 	return priv->read(priv, AR8216_REG_PORT_STATUS(port));
 }
 
 static void
-ar8216_setup_port(struct ar8216_priv *priv, int port, u32 egress, u32 ingress,
+ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 egress, u32 ingress,
 		  u32 members, u32 pvid)
 {
 	u32 header;
@@ -630,7 +732,7 @@ ar8216_setup_port(struct ar8216_priv *pr
 	else
 		header = 0;
 
-	ar8216_rmw(priv, AR8216_REG_PORT_CTRL(port),
+	ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
 		   AR8216_PORT_CTRL_LEARN | AR8216_PORT_CTRL_VLAN_MODE |
 		   AR8216_PORT_CTRL_SINGLE_VLAN | AR8216_PORT_CTRL_STATE |
 		   AR8216_PORT_CTRL_HEADER | AR8216_PORT_CTRL_LEARN_LOCK,
@@ -638,7 +740,7 @@ ar8216_setup_port(struct ar8216_priv *pr
 		   (egress << AR8216_PORT_CTRL_VLAN_MODE_S) |
 		   (AR8216_PORT_STATE_FORWARD << AR8216_PORT_CTRL_STATE_S));
 
-	ar8216_rmw(priv, AR8216_REG_PORT_VLAN(port),
+	ar8xxx_rmw(priv, AR8216_REG_PORT_VLAN(port),
 		   AR8216_PORT_VLAN_DEST_PORTS | AR8216_PORT_VLAN_MODE |
 		   AR8216_PORT_VLAN_DEFAULT_ID,
 		   (members << AR8216_PORT_VLAN_DEST_PORTS_S) |
@@ -647,23 +749,23 @@ ar8216_setup_port(struct ar8216_priv *pr
 }
 
 static int
-ar8216_hw_init(struct ar8216_priv *priv)
+ar8216_hw_init(struct ar8xxx_priv *priv)
 {
 	return 0;
 }
 
 static void
-ar8216_init_globals(struct ar8216_priv *priv)
+ar8216_init_globals(struct ar8xxx_priv *priv)
 {
 	/* standard atheros magic */
 	priv->write(priv, 0x38, 0xc000050e);
 
-	ar8216_rmw(priv, AR8216_REG_GLOBAL_CTRL,
+	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
 		   AR8216_GCTRL_MTU, 1518 + 8 + 2);
 }
 
 static void
-ar8216_init_port(struct ar8216_priv *priv, int port)
+ar8216_init_port(struct ar8xxx_priv *priv, int port)
 {
 	/* Enable port learning and tx */
 	priv->write(priv, AR8216_REG_PORT_CTRL(port),
@@ -705,10 +807,10 @@ static const struct ar8xxx_chip ar8216_c
 };
 
 static void
-ar8236_setup_port(struct ar8216_priv *priv, int port, u32 egress, u32 ingress,
+ar8236_setup_port(struct ar8xxx_priv *priv, int port, u32 egress, u32 ingress,
 		  u32 members, u32 pvid)
 {
-	ar8216_rmw(priv, AR8216_REG_PORT_CTRL(port),
+	ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
 		   AR8216_PORT_CTRL_LEARN | AR8216_PORT_CTRL_VLAN_MODE |
 		   AR8216_PORT_CTRL_SINGLE_VLAN | AR8216_PORT_CTRL_STATE |
 		   AR8216_PORT_CTRL_HEADER | AR8216_PORT_CTRL_LEARN_LOCK,
@@ -716,11 +818,11 @@ ar8236_setup_port(struct ar8216_priv *pr
 		   (egress << AR8216_PORT_CTRL_VLAN_MODE_S) |
 		   (AR8216_PORT_STATE_FORWARD << AR8216_PORT_CTRL_STATE_S));
 
-	ar8216_rmw(priv, AR8236_REG_PORT_VLAN(port),
+	ar8xxx_rmw(priv, AR8236_REG_PORT_VLAN(port),
 		   AR8236_PORT_VLAN_DEFAULT_ID,
 		   (pvid << AR8236_PORT_VLAN_DEFAULT_ID_S));
 
-	ar8216_rmw(priv, AR8236_REG_PORT_VLAN2(port),
+	ar8xxx_rmw(priv, AR8236_REG_PORT_VLAN2(port),
 		   AR8236_PORT_VLAN2_VLAN_MODE |
 		   AR8236_PORT_VLAN2_MEMBER,
 		   (ingress << AR8236_PORT_VLAN2_VLAN_MODE_S) |
@@ -728,7 +830,7 @@ ar8236_setup_port(struct ar8216_priv *pr
 }
 
 static int
-ar8236_hw_init(struct ar8216_priv *priv)
+ar8236_hw_init(struct ar8xxx_priv *priv)
 {
 	int i;
 	struct mii_bus *bus;
@@ -737,7 +839,7 @@ ar8236_hw_init(struct ar8216_priv *priv)
 		return 0;
 
 	/* Initialize the PHYs */
-	bus = priv->phy->bus;
+	bus = priv->mii_bus;
 	for (i = 0; i < 5; i++) {
 		mdiobus_write(bus, i, MII_ADVERTISE,
 			      ADVERTISE_ALL | ADVERTISE_PAUSE_CAP |
@@ -751,14 +853,14 @@ ar8236_hw_init(struct ar8216_priv *priv)
 }
 
 static void
-ar8236_init_globals(struct ar8216_priv *priv)
+ar8236_init_globals(struct ar8xxx_priv *priv)
 {
 	/* enable jumbo frames */
-	ar8216_rmw(priv, AR8216_REG_GLOBAL_CTRL,
+	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
 		   AR8316_GCTRL_MTU, 9018 + 8 + 2);
 
 	/* Enable MIB counters */
-	ar8216_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
+	ar8xxx_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
 		   (AR8216_MIB_FUNC_NO_OP << AR8216_MIB_FUNC_S) |
 		   AR8236_MIB_EN);
 }
@@ -779,67 +881,68 @@ static const struct ar8xxx_chip ar8236_c
 };
 
 static int
-ar8316_hw_init(struct ar8216_priv *priv)
+ar8316_hw_init(struct ar8xxx_priv *priv)
 {
 	int i;
 	u32 val, newval;
 	struct mii_bus *bus;
 
-	val = priv->read(priv, 0x8);
+	val = priv->read(priv, AR8316_REG_POSTRIP);
 
 	if (priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
 		if (priv->port4_phy) {
 			/* value taken from Ubiquiti RouterStation Pro */
 			newval = 0x81461bea;
-			printk(KERN_INFO "ar8316: Using port 4 as PHY\n");
+			pr_info("ar8316: Using port 4 as PHY\n");
 		} else {
 			newval = 0x01261be2;
-			printk(KERN_INFO "ar8316: Using port 4 as switch port\n");
+			pr_info("ar8316: Using port 4 as switch port\n");
 		}
 	} else if (priv->phy->interface == PHY_INTERFACE_MODE_GMII) {
 		/* value taken from AVM Fritz!Box 7390 sources */
 		newval = 0x010e5b71;
 	} else {
 		/* no known value for phy interface */
-		printk(KERN_ERR "ar8316: unsupported mii mode: %d.\n",
-			priv->phy->interface);
+		pr_err("ar8316: unsupported mii mode: %d.\n",
+		       priv->phy->interface);
 		return -EINVAL;
 	}
 
 	if (val == newval)
 		goto out;
 
-	priv->write(priv, 0x8, newval);
+	priv->write(priv, AR8316_REG_POSTRIP, newval);
+
+	if (priv->port4_phy &&
+	    priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
+		/* work around for phy4 rgmii mode */
+		ar8xxx_phy_dbg_write(priv, 4, 0x12, 0x480c);
+		/* rx delay */
+		ar8xxx_phy_dbg_write(priv, 4, 0x0, 0x824e);
+		/* tx delay */
+		ar8xxx_phy_dbg_write(priv, 4, 0x5, 0x3d47);
+		msleep(1000);
+	}
 
 	/* Initialize the ports */
-	bus = priv->phy->bus;
+	bus = priv->mii_bus;
 	for (i = 0; i < 5; i++) {
-		if ((i == 4) && priv->port4_phy &&
-		    priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
-			/* work around for phy4 rgmii mode */
-			ar8216_phy_dbg_write(priv, i, 0x12, 0x480c);
-			/* rx delay */
-			ar8216_phy_dbg_write(priv, i, 0x0, 0x824e);
-			/* tx delay */
-			ar8216_phy_dbg_write(priv, i, 0x5, 0x3d47);
-			msleep(1000);
-		}
-
 		/* initialize the port itself */
 		mdiobus_write(bus, i, MII_ADVERTISE,
 			ADVERTISE_ALL | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
 		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
 		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
-		msleep(1000);
 	}
 
+	msleep(1000);
+
 out:
 	priv->initialized = true;
 	return 0;
 }
 
 static void
-ar8316_init_globals(struct ar8216_priv *priv)
+ar8316_init_globals(struct ar8xxx_priv *priv)
 {
 	/* standard atheros magic */
 	priv->write(priv, 0x38, 0xc000050e);
@@ -848,11 +951,11 @@ ar8316_init_globals(struct ar8216_priv *
 	priv->write(priv, AR8216_REG_FLOOD_MASK, 0x003f003f);
 
 	/* enable jumbo frames */
-	ar8216_rmw(priv, AR8216_REG_GLOBAL_CTRL,
+	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
 		   AR8316_GCTRL_MTU, 9018 + 8 + 2);
 
 	/* Enable MIB counters */
-	ar8216_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
+	ar8xxx_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
 		   (AR8216_MIB_FUNC_NO_OP << AR8216_MIB_FUNC_S) |
 		   AR8236_MIB_EN);
 }
@@ -917,6 +1020,9 @@ ar8327_get_pad_cfg(struct ar8327_pad_cfg
 		if (cfg->txclk_delay_en)
 			t |= AR8327_PAD_RGMII_TXCLK_DELAY_EN;
 
+		if (cfg->sgmii_delay_en)
+			t |= AR8327_PAD_SGMII_DELAY_EN;
+
 		break;
 
 	case AR8327_PAD_MAC2PHY_MII:
@@ -964,232 +1070,656 @@ ar8327_get_pad_cfg(struct ar8327_pad_cfg
 }
 
 static void
-ar8327_phy_fixup(struct ar8216_priv *priv, int phy)
+ar8327_phy_fixup(struct ar8xxx_priv *priv, int phy)
 {
 	switch (priv->chip_rev) {
 	case 1:
 		/* For 100M waveform */
-		ar8216_phy_dbg_write(priv, phy, 0, 0x02ea);
+		ar8xxx_phy_dbg_write(priv, phy, 0, 0x02ea);
 		/* Turn on Gigabit clock */
-		ar8216_phy_dbg_write(priv, phy, 0x3d, 0x68a0);
+		ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x68a0);
 		break;
 
 	case 2:
-		ar8216_phy_mmd_write(priv, phy, 0x7, 0x3c);
-		ar8216_phy_mmd_write(priv, phy, 0x4007, 0x0);
+		ar8xxx_phy_mmd_write(priv, phy, 0x7, 0x3c);
+		ar8xxx_phy_mmd_write(priv, phy, 0x4007, 0x0);
 		/* fallthrough */
 	case 4:
-		ar8216_phy_mmd_write(priv, phy, 0x3, 0x800d);
-		ar8216_phy_mmd_write(priv, phy, 0x4003, 0x803f);
+		ar8xxx_phy_mmd_write(priv, phy, 0x3, 0x800d);
+		ar8xxx_phy_mmd_write(priv, phy, 0x4003, 0x803f);
 
-		ar8216_phy_dbg_write(priv, phy, 0x3d, 0x6860);
-		ar8216_phy_dbg_write(priv, phy, 0x5, 0x2c46);
-		ar8216_phy_dbg_write(priv, phy, 0x3c, 0x6000);
+		ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x6860);
+		ar8xxx_phy_dbg_write(priv, phy, 0x5, 0x2c46);
+		ar8xxx_phy_dbg_write(priv, phy, 0x3c, 0x6000);
 		break;
 	}
 }
 
-static int
-ar8327_hw_init(struct ar8216_priv *priv)
+static u32
+ar8327_get_port_init_status(struct ar8327_port_cfg *cfg)
 {
-	struct ar8327_platform_data *pdata;
-	struct ar8327_led_cfg *led_cfg;
-	struct mii_bus *bus;
-	u32 pos, new_pos;
 	u32 t;
-	int i;
-
-	pdata = priv->phy->dev.platform_data;
-	if (!pdata)
-		return -EINVAL;
-
-	t = ar8327_get_pad_cfg(pdata->pad0_cfg);
-	priv->write(priv, AR8327_REG_PAD0_MODE, t);
-	t = ar8327_get_pad_cfg(pdata->pad5_cfg);
-	priv->write(priv, AR8327_REG_PAD5_MODE, t);
-	t = ar8327_get_pad_cfg(pdata->pad6_cfg);
-	priv->write(priv, AR8327_REG_PAD6_MODE, t);
 
-	pos = priv->read(priv, AR8327_REG_POWER_ON_STRIP);
-	new_pos = pos;
+	if (!cfg->force_link)
+		return AR8216_PORT_STATUS_LINK_AUTO;
 
-	led_cfg = pdata->led_cfg;
-	if (led_cfg) {
-		if (led_cfg->open_drain)
-			new_pos |= AR8327_POWER_ON_STRIP_LED_OPEN_EN;
-		else
-			new_pos &= ~AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+	t = AR8216_PORT_STATUS_TXMAC | AR8216_PORT_STATUS_RXMAC;
+	t |= cfg->duplex ? AR8216_PORT_STATUS_DUPLEX : 0;
+	t |= cfg->rxpause ? AR8216_PORT_STATUS_RXFLOW : 0;
+	t |= cfg->txpause ? AR8216_PORT_STATUS_TXFLOW : 0;
 
-		priv->write(priv, AR8327_REG_LED_CTRL0, led_cfg->led_ctrl0);
-		priv->write(priv, AR8327_REG_LED_CTRL1, led_cfg->led_ctrl1);
-		priv->write(priv, AR8327_REG_LED_CTRL2, led_cfg->led_ctrl2);
-		priv->write(priv, AR8327_REG_LED_CTRL3, led_cfg->led_ctrl3);
+	switch (cfg->speed) {
+	case AR8327_PORT_SPEED_10:
+		t |= AR8216_PORT_SPEED_10M;
+		break;
+	case AR8327_PORT_SPEED_100:
+		t |= AR8216_PORT_SPEED_100M;
+		break;
+	case AR8327_PORT_SPEED_1000:
+		t |= AR8216_PORT_SPEED_1000M;
+		break;
 	}
 
-	if (new_pos != pos) {
-		new_pos |= AR8327_POWER_ON_STRIP_POWER_ON_SEL;
-		priv->write(priv, AR8327_REG_POWER_ON_STRIP, new_pos);
-	}
+	return t;
+}
 
-	bus = priv->phy->bus;
-	for (i = 0; i < AR8327_NUM_PHYS; i++) {
-		ar8327_phy_fixup(priv, i);
+#define AR8327_LED_ENTRY(_num, _reg, _shift) \
+	[_num] = { .reg = (_reg), .shift = (_shift) }
 
-		/* start aneg on the PHY */
-		mdiobus_write(bus, i, MII_ADVERTISE, ADVERTISE_ALL |
-						     ADVERTISE_PAUSE_CAP |
-						     ADVERTISE_PAUSE_ASYM);
-		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
-		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
-	}
+static const struct ar8327_led_entry
+ar8327_led_map[AR8327_NUM_LEDS] = {
+	AR8327_LED_ENTRY(AR8327_LED_PHY0_0, 0, 14),
+	AR8327_LED_ENTRY(AR8327_LED_PHY0_1, 1, 14),
+	AR8327_LED_ENTRY(AR8327_LED_PHY0_2, 2, 14),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY1_0, 3, 8),
+	AR8327_LED_ENTRY(AR8327_LED_PHY1_1, 3, 10),
+	AR8327_LED_ENTRY(AR8327_LED_PHY1_2, 3, 12),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY2_0, 3, 14),
+	AR8327_LED_ENTRY(AR8327_LED_PHY2_1, 3, 16),
+	AR8327_LED_ENTRY(AR8327_LED_PHY2_2, 3, 18),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY3_0, 3, 20),
+	AR8327_LED_ENTRY(AR8327_LED_PHY3_1, 3, 22),
+	AR8327_LED_ENTRY(AR8327_LED_PHY3_2, 3, 24),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY4_0, 0, 30),
+	AR8327_LED_ENTRY(AR8327_LED_PHY4_1, 1, 30),
+	AR8327_LED_ENTRY(AR8327_LED_PHY4_2, 2, 30),
+};
 
-	msleep(1000);
+static void
+ar8327_set_led_pattern(struct ar8xxx_priv *priv, unsigned int led_num,
+		       enum ar8327_led_pattern pattern)
+{
+	const struct ar8327_led_entry *entry;
 
-	return 0;
+	entry = &ar8327_led_map[led_num];
+	ar8xxx_rmw(priv, AR8327_REG_LED_CTRL(entry->reg),
+		   (3 << entry->shift), pattern << entry->shift);
 }
 
 static void
-ar8327_init_globals(struct ar8216_priv *priv)
+ar8327_led_work_func(struct work_struct *work)
 {
-	u32 t;
-
-	/* enable CPU port and disable mirror port */
-	t = AR8327_FWD_CTRL0_CPU_PORT_EN |
-	    AR8327_FWD_CTRL0_MIRROR_PORT;
-	priv->write(priv, AR8327_REG_FWD_CTRL0, t);
+	struct ar8327_led *aled;
+	u8 pattern;
 
-	/* forward multicast and broadcast frames to CPU */
-	t = (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_UC_FLOOD_S) |
-	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_MC_FLOOD_S) |
-	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_BC_FLOOD_S);
-	priv->write(priv, AR8327_REG_FWD_CTRL1, t);
+	aled = container_of(work, struct ar8327_led, led_work);
 
-	/* setup MTU */
-	ar8216_rmw(priv, AR8327_REG_MAX_FRAME_SIZE,
-		   AR8327_MAX_FRAME_SIZE_MTU, 1518 + 8 + 2);
+	spin_lock(&aled->lock);
+	pattern = aled->pattern;
+	spin_unlock(&aled->lock);
 
-	/* Enable MIB counters */
-	ar8216_reg_set(priv, AR8327_REG_MODULE_EN,
-		       AR8327_MODULE_EN_MIB);
+	ar8327_set_led_pattern(aled->sw_priv, aled->led_num,
+			       pattern);
 }
 
 static void
-ar8327_init_cpuport(struct ar8216_priv *priv)
+ar8327_led_schedule_change(struct ar8327_led *aled, u8 pattern)
 {
-	struct ar8327_platform_data *pdata;
-	struct ar8327_port_cfg *cfg;
-	u32 t;
-
-	pdata = priv->phy->dev.platform_data;
-	if (!pdata)
+	if (aled->pattern == pattern)
 		return;
 
-	cfg = &pdata->cpuport_cfg;
-	if (!cfg->force_link) {
-		priv->write(priv, AR8327_REG_PORT_STATUS(AR8216_PORT_CPU),
-			    AR8216_PORT_STATUS_LINK_AUTO);
-		return;
+	aled->pattern = pattern;
+	schedule_work(&aled->led_work);
+}
+
+static inline struct ar8327_led *
+led_cdev_to_ar8327_led(struct led_classdev *led_cdev)
+{
+	return container_of(led_cdev, struct ar8327_led, cdev);
+}
+
+static int
+ar8327_led_blink_set(struct led_classdev *led_cdev,
+		     unsigned long *delay_on,
+		     unsigned long *delay_off)
+{
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+
+	if (*delay_on == 0 && *delay_off == 0) {
+		*delay_on = 125;
+		*delay_off = 125;
 	}
 
-	t = AR8216_PORT_STATUS_TXMAC | AR8216_PORT_STATUS_RXMAC;
-	t |= cfg->duplex ? AR8216_PORT_STATUS_DUPLEX : 0;
-	t |= cfg->rxpause ? AR8216_PORT_STATUS_RXFLOW : 0;
-	t |= cfg->txpause ? AR8216_PORT_STATUS_TXFLOW : 0;
-	switch (cfg->speed) {
-	case AR8327_PORT_SPEED_10:
-		t |= AR8216_PORT_SPEED_10M;
-		break;
-	case AR8327_PORT_SPEED_100:
-		t |= AR8216_PORT_SPEED_100M;
-		break;
-	case AR8327_PORT_SPEED_1000:
-		t |= AR8216_PORT_SPEED_1000M;
-		break;
+	if (*delay_on != 125 || *delay_off != 125) {
+		/*
+		 * The hardware only supports blinking at 4Hz. Fall back
+		 * to software implementation in other cases.
+		 */
+		return -EINVAL;
 	}
 
-	priv->write(priv, AR8327_REG_PORT_STATUS(AR8216_PORT_CPU), t);
+	spin_lock(&aled->lock);
+
+	aled->enable_hw_mode = false;
+	ar8327_led_schedule_change(aled, AR8327_LED_PATTERN_BLINK);
+
+	spin_unlock(&aled->lock);
+
+	return 0;
 }
 
 static void
-ar8327_init_port(struct ar8216_priv *priv, int port)
+ar8327_led_set_brightness(struct led_classdev *led_cdev,
+			  enum led_brightness brightness)
 {
-	u32 t;
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+	u8 pattern;
+	bool active;
 
-	if (port == AR8216_PORT_CPU) {
-		ar8327_init_cpuport(priv);
-	} else {
-		t = AR8216_PORT_STATUS_LINK_AUTO;
-		priv->write(priv, AR8327_REG_PORT_STATUS(port), t);
-	}
+	active = (brightness != LED_OFF);
+	active ^= aled->active_low;
 
-	priv->write(priv, AR8327_REG_PORT_HEADER(port), 0);
+	pattern = (active) ? AR8327_LED_PATTERN_ON :
+			     AR8327_LED_PATTERN_OFF;
 
-	priv->write(priv, AR8327_REG_PORT_VLAN0(port), 0);
+	spin_lock(&aled->lock);
 
-	t = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH << AR8327_PORT_VLAN1_OUT_MODE_S;
-	priv->write(priv, AR8327_REG_PORT_VLAN1(port), t);
+	aled->enable_hw_mode = false;
+	ar8327_led_schedule_change(aled, pattern);
 
-	t = AR8327_PORT_LOOKUP_LEARN;
-	t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
-	priv->write(priv, AR8327_REG_PORT_LOOKUP(port), t);
+	spin_unlock(&aled->lock);
 }
 
-static u32
-ar8327_read_port_status(struct ar8216_priv *priv, int port)
+static ssize_t
+ar8327_led_enable_hw_mode_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
 {
-	return priv->read(priv, AR8327_REG_PORT_STATUS(port));
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+	ssize_t ret = 0;
+
+	spin_lock(&aled->lock);
+	ret += sprintf(buf, "%d\n", aled->enable_hw_mode);
+	spin_unlock(&aled->lock);
+
+	return ret;
+}
+
+static ssize_t
+ar8327_led_enable_hw_mode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf,
+				size_t size)
+{
+        struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+	u8 pattern;
+	u8 value;
+	int ret;
+
+	ret = kstrtou8(buf, 10, &value);
+	if (ret < 0)
+		return -EINVAL;
+
+	spin_lock(&aled->lock);
+
+	aled->enable_hw_mode = !!value;
+	if (aled->enable_hw_mode)
+		pattern = AR8327_LED_PATTERN_RULE;
+	else
+		pattern = AR8327_LED_PATTERN_OFF;
+
+	ar8327_led_schedule_change(aled, pattern);
+
+	spin_unlock(&aled->lock);
+
+	return size;
 }
 
+static DEVICE_ATTR(enable_hw_mode,  S_IRUGO | S_IWUSR,
+		   ar8327_led_enable_hw_mode_show,
+		   ar8327_led_enable_hw_mode_store);
+
 static int
-ar8327_atu_flush(struct ar8216_priv *priv)
+ar8327_led_register(struct ar8xxx_priv *priv, struct ar8327_led *aled)
 {
 	int ret;
 
-	ret = ar8216_wait_bit(priv, AR8327_REG_ATU_FUNC,
-			      AR8327_ATU_FUNC_BUSY, 0);
-	if (!ret)
-		priv->write(priv, AR8327_REG_ATU_FUNC,
-			    AR8327_ATU_FUNC_OP_FLUSH);
+	ret = led_classdev_register(NULL, &aled->cdev);
+	if (ret < 0)
+		return ret;
+
+	if (aled->mode == AR8327_LED_MODE_HW) {
+		ret = device_create_file(aled->cdev.dev,
+					 &dev_attr_enable_hw_mode);
+		if (ret)
+			goto err_unregister;
+	}
+
+	return 0;
 
+err_unregister:
+	led_classdev_unregister(&aled->cdev);
 	return ret;
 }
 
 static void
-ar8327_vtu_op(struct ar8216_priv *priv, u32 op, u32 val)
+ar8327_led_unregister(struct ar8327_led *aled)
 {
-	if (ar8216_wait_bit(priv, AR8327_REG_VTU_FUNC1,
-			    AR8327_VTU_FUNC1_BUSY, 0))
-		return;
+	if (aled->mode == AR8327_LED_MODE_HW)
+		device_remove_file(aled->cdev.dev, &dev_attr_enable_hw_mode);
 
-	if ((op & AR8327_VTU_FUNC1_OP) == AR8327_VTU_FUNC1_OP_LOAD)
-		priv->write(priv, AR8327_REG_VTU_FUNC0, val);
+	led_classdev_unregister(&aled->cdev);
+	cancel_work_sync(&aled->led_work);
+}
 
-	op |= AR8327_VTU_FUNC1_BUSY;
-	priv->write(priv, AR8327_REG_VTU_FUNC1, op);
+static int
+ar8327_led_create(struct ar8xxx_priv *priv,
+		  const struct ar8327_led_info *led_info)
+{
+	struct ar8327_data *data = &priv->chip_data.ar8327;
+	struct ar8327_led *aled;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
+		return 0;
+
+	if (!led_info->name)
+		return -EINVAL;
+
+	if (led_info->led_num >= AR8327_NUM_LEDS)
+		return -EINVAL;
+
+	aled = kzalloc(sizeof(*aled) + strlen(led_info->name) + 1,
+		       GFP_KERNEL);
+	if (!aled)
+		return -ENOMEM;
+
+	aled->sw_priv = priv;
+	aled->led_num = led_info->led_num;
+	aled->active_low = led_info->active_low;
+	aled->mode = led_info->mode;
+
+	if (aled->mode == AR8327_LED_MODE_HW)
+		aled->enable_hw_mode = true;
+
+	aled->name = (char *)(aled + 1);
+	strcpy(aled->name, led_info->name);
+
+	aled->cdev.name = aled->name;
+	aled->cdev.brightness_set = ar8327_led_set_brightness;
+	aled->cdev.blink_set = ar8327_led_blink_set;
+	aled->cdev.default_trigger = led_info->default_trigger;
+
+	spin_lock_init(&aled->lock);
+	mutex_init(&aled->mutex);
+	INIT_WORK(&aled->led_work, ar8327_led_work_func);
+
+	ret = ar8327_led_register(priv, aled);
+	if (ret)
+		goto err_free;
+
+	data->leds[data->num_leds++] = aled;
+
+	return 0;
+
+err_free:
+	kfree(aled);
+	return ret;
 }
 
 static void
-ar8327_vtu_flush(struct ar8216_priv *priv)
+ar8327_led_destroy(struct ar8327_led *aled)
 {
-	ar8327_vtu_op(priv, AR8327_VTU_FUNC1_OP_FLUSH, 0);
+	ar8327_led_unregister(aled);
+	kfree(aled);
 }
 
 static void
-ar8327_vtu_load_vlan(struct ar8216_priv *priv, u32 vid, u32 port_mask)
+ar8327_leds_init(struct ar8xxx_priv *priv)
 {
-	u32 op;
-	u32 val;
-	int i;
+	struct ar8327_data *data;
+	unsigned i;
 
-	op = AR8327_VTU_FUNC1_OP_LOAD | (vid << AR8327_VTU_FUNC1_VID_S);
-	val = AR8327_VTU_FUNC0_VALID | AR8327_VTU_FUNC0_IVL;
-	for (i = 0; i < AR8327_NUM_PORTS; i++) {
-		u32 mode;
+	if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
+		return;
 
-		if ((port_mask & BIT(i)) == 0)
-			mode = AR8327_VTU_FUNC0_EG_MODE_NOT;
-		else if (priv->vlan == 0)
-			mode = AR8327_VTU_FUNC0_EG_MODE_KEEP;
+	data = &priv->chip_data.ar8327;
+
+	for (i = 0; i < data->num_leds; i++) {
+		struct ar8327_led *aled;
+
+		aled = data->leds[i];
+
+		if (aled->enable_hw_mode)
+			aled->pattern = AR8327_LED_PATTERN_RULE;
+		else
+			aled->pattern = AR8327_LED_PATTERN_OFF;
+
+		ar8327_set_led_pattern(priv, aled->led_num, aled->pattern);
+	}
+}
+
+static void
+ar8327_leds_cleanup(struct ar8xxx_priv *priv)
+{
+	struct ar8327_data *data = &priv->chip_data.ar8327;
+	unsigned i;
+
+	if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
+		return;
+
+	for (i = 0; i < data->num_leds; i++) {
+		struct ar8327_led *aled;
+
+		aled = data->leds[i];
+		ar8327_led_destroy(aled);
+	}
+
+	kfree(data->leds);
+}
+
+static int
+ar8327_hw_config_pdata(struct ar8xxx_priv *priv,
+		       struct ar8327_platform_data *pdata)
+{
+	struct ar8327_led_cfg *led_cfg;
+	struct ar8327_data *data;
+	u32 pos, new_pos;
+	u32 t;
+
+	if (!pdata)
+		return -EINVAL;
+
+	priv->get_port_link = pdata->get_port_link;
+
+	data = &priv->chip_data.ar8327;
+
+	data->port0_status = ar8327_get_port_init_status(&pdata->port0_cfg);
+	data->port6_status = ar8327_get_port_init_status(&pdata->port6_cfg);
+
+	t = ar8327_get_pad_cfg(pdata->pad0_cfg);
+	if (chip_is_ar8337(priv))
+		t |= AR8337_PAD_MAC06_EXCHANGE_EN;
+
+	priv->write(priv, AR8327_REG_PAD0_MODE, t);
+	t = ar8327_get_pad_cfg(pdata->pad5_cfg);
+	priv->write(priv, AR8327_REG_PAD5_MODE, t);
+	t = ar8327_get_pad_cfg(pdata->pad6_cfg);
+	priv->write(priv, AR8327_REG_PAD6_MODE, t);
+
+	pos = priv->read(priv, AR8327_REG_POWER_ON_STRIP);
+	new_pos = pos;
+
+	led_cfg = pdata->led_cfg;
+	if (led_cfg) {
+		if (led_cfg->open_drain)
+			new_pos |= AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+		else
+			new_pos &= ~AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+
+		priv->write(priv, AR8327_REG_LED_CTRL0, led_cfg->led_ctrl0);
+		priv->write(priv, AR8327_REG_LED_CTRL1, led_cfg->led_ctrl1);
+		priv->write(priv, AR8327_REG_LED_CTRL2, led_cfg->led_ctrl2);
+		priv->write(priv, AR8327_REG_LED_CTRL3, led_cfg->led_ctrl3);
+
+		if (new_pos != pos)
+			new_pos |= AR8327_POWER_ON_STRIP_POWER_ON_SEL;
+	}
+
+	if (pdata->sgmii_cfg) {
+		t = pdata->sgmii_cfg->sgmii_ctrl;
+		if (priv->chip_rev == 1)
+			t |= AR8327_SGMII_CTRL_EN_PLL |
+			     AR8327_SGMII_CTRL_EN_RX |
+			     AR8327_SGMII_CTRL_EN_TX;
+		else
+			t &= ~(AR8327_SGMII_CTRL_EN_PLL |
+			       AR8327_SGMII_CTRL_EN_RX |
+			       AR8327_SGMII_CTRL_EN_TX);
+
+		priv->write(priv, AR8327_REG_SGMII_CTRL, t);
+
+		if (pdata->sgmii_cfg->serdes_aen)
+			new_pos &= ~AR8327_POWER_ON_STRIP_SERDES_AEN;
+		else
+			new_pos |= AR8327_POWER_ON_STRIP_SERDES_AEN;
+	}
+
+	priv->write(priv, AR8327_REG_POWER_ON_STRIP, new_pos);
+
+	if (pdata->leds && pdata->num_leds) {
+		int i;
+
+		data->leds = kzalloc(pdata->num_leds * sizeof(void *),
+				     GFP_KERNEL);
+		if (!data->leds)
+			return -ENOMEM;
+
+		for (i = 0; i < pdata->num_leds; i++)
+			ar8327_led_create(priv, &pdata->leds[i]);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int
+ar8327_hw_config_of(struct ar8xxx_priv *priv, struct device_node *np)
+{
+	const __be32 *paddr;
+	int len;
+	int i;
+
+	paddr = of_get_property(np, "qca,ar8327-initvals", &len);
+	if (!paddr || len < (2 * sizeof(*paddr)))
+		return -EINVAL;
+
+	len /= sizeof(*paddr);
+
+	for (i = 0; i < len - 1; i += 2) {
+		u32 reg;
+		u32 val;
+
+		reg = be32_to_cpup(paddr + i);
+		val = be32_to_cpup(paddr + i + 1);
+
+		switch (reg) {
+		case AR8327_REG_PORT_STATUS(0):
+			priv->chip_data.ar8327.port0_status = val;
+			break;
+		case AR8327_REG_PORT_STATUS(6):
+			priv->chip_data.ar8327.port6_status = val;
+			break;
+		default:
+			priv->write(priv, reg, val);
+			break;
+		}
+	}
+
+	return 0;
+}
+#else
+static inline int
+ar8327_hw_config_of(struct ar8xxx_priv *priv, struct device_node *np)
+{
+	return -EINVAL;
+}
+#endif
+
+static int
+ar8327_hw_init(struct ar8xxx_priv *priv)
+{
+	struct mii_bus *bus;
+	int ret;
+	int i;
+
+	if (priv->phy->dev.of_node)
+		ret = ar8327_hw_config_of(priv, priv->phy->dev.of_node);
+	else
+		ret = ar8327_hw_config_pdata(priv,
+					     priv->phy->dev.platform_data);
+
+	if (ret)
+		return ret;
+
+	ar8327_leds_init(priv);
+
+	bus = priv->mii_bus;
+	for (i = 0; i < AR8327_NUM_PHYS; i++) {
+		ar8327_phy_fixup(priv, i);
+
+		/* start aneg on the PHY */
+		mdiobus_write(bus, i, MII_ADVERTISE, ADVERTISE_ALL |
+						     ADVERTISE_PAUSE_CAP |
+						     ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	}
+
+	msleep(1000);
+
+	return 0;
+}
+
+static void
+ar8327_cleanup(struct ar8xxx_priv *priv)
+{
+	ar8327_leds_cleanup(priv);
+}
+
+static void
+ar8327_init_globals(struct ar8xxx_priv *priv)
+{
+	u32 t;
+
+	/* enable CPU port and disable mirror port */
+	t = AR8327_FWD_CTRL0_CPU_PORT_EN |
+	    AR8327_FWD_CTRL0_MIRROR_PORT;
+	priv->write(priv, AR8327_REG_FWD_CTRL0, t);
+
+	/* forward multicast and broadcast frames to CPU */
+	t = (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_UC_FLOOD_S) |
+	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_MC_FLOOD_S) |
+	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_BC_FLOOD_S);
+	priv->write(priv, AR8327_REG_FWD_CTRL1, t);
+
+	/* enable jumbo frames */
+	ar8xxx_rmw(priv, AR8327_REG_MAX_FRAME_SIZE,
+		   AR8327_MAX_FRAME_SIZE_MTU, 9018 + 8 + 2);
+
+	/* Enable MIB counters */
+	ar8xxx_reg_set(priv, AR8327_REG_MODULE_EN,
+		       AR8327_MODULE_EN_MIB);
+
+	/* Disable EEE on all ports due to stability issues */
+	t = priv->read(priv, AR8327_REG_EEE_CTRL);
+	t |= AR8327_EEE_CTRL_DISABLE_PHY(0) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(1) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(2) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(3) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(4);
+	priv->write(priv, AR8327_REG_EEE_CTRL, t);
+}
+
+static void
+ar8327_init_port(struct ar8xxx_priv *priv, int port)
+{
+	u32 t;
+
+	if (port == AR8216_PORT_CPU)
+		t = priv->chip_data.ar8327.port0_status;
+	else if (port == 6)
+		t = priv->chip_data.ar8327.port6_status;
+	else
+		t = AR8216_PORT_STATUS_LINK_AUTO;
+
+	priv->write(priv, AR8327_REG_PORT_STATUS(port), t);
+	priv->write(priv, AR8327_REG_PORT_HEADER(port), 0);
+
+	t = 1 << AR8327_PORT_VLAN0_DEF_SVID_S;
+	t |= 1 << AR8327_PORT_VLAN0_DEF_CVID_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN0(port), t);
+
+	t = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH << AR8327_PORT_VLAN1_OUT_MODE_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN1(port), t);
+
+	t = AR8327_PORT_LOOKUP_LEARN;
+	t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
+	priv->write(priv, AR8327_REG_PORT_LOOKUP(port), t);
+}
+
+static u32
+ar8327_read_port_status(struct ar8xxx_priv *priv, int port)
+{
+	return priv->read(priv, AR8327_REG_PORT_STATUS(port));
+}
+
+static int
+ar8327_atu_flush(struct ar8xxx_priv *priv)
+{
+	int ret;
+
+	ret = ar8216_wait_bit(priv, AR8327_REG_ATU_FUNC,
+			      AR8327_ATU_FUNC_BUSY, 0);
+	if (!ret)
+		priv->write(priv, AR8327_REG_ATU_FUNC,
+			    AR8327_ATU_FUNC_OP_FLUSH);
+
+	return ret;
+}
+
+static void
+ar8327_vtu_op(struct ar8xxx_priv *priv, u32 op, u32 val)
+{
+	if (ar8216_wait_bit(priv, AR8327_REG_VTU_FUNC1,
+			    AR8327_VTU_FUNC1_BUSY, 0))
+		return;
+
+	if ((op & AR8327_VTU_FUNC1_OP) == AR8327_VTU_FUNC1_OP_LOAD)
+		priv->write(priv, AR8327_REG_VTU_FUNC0, val);
+
+	op |= AR8327_VTU_FUNC1_BUSY;
+	priv->write(priv, AR8327_REG_VTU_FUNC1, op);
+}
+
+static void
+ar8327_vtu_flush(struct ar8xxx_priv *priv)
+{
+	ar8327_vtu_op(priv, AR8327_VTU_FUNC1_OP_FLUSH, 0);
+}
+
+static void
+ar8327_vtu_load_vlan(struct ar8xxx_priv *priv, u32 vid, u32 port_mask)
+{
+	u32 op;
+	u32 val;
+	int i;
+
+	op = AR8327_VTU_FUNC1_OP_LOAD | (vid << AR8327_VTU_FUNC1_VID_S);
+	val = AR8327_VTU_FUNC0_VALID | AR8327_VTU_FUNC0_IVL;
+	for (i = 0; i < AR8327_NUM_PORTS; i++) {
+		u32 mode;
+
+		if ((port_mask & BIT(i)) == 0)
+			mode = AR8327_VTU_FUNC0_EG_MODE_NOT;
+		else if (priv->vlan == 0)
+			mode = AR8327_VTU_FUNC0_EG_MODE_KEEP;
 		else if (priv->vlan_tagged & BIT(i))
 			mode = AR8327_VTU_FUNC0_EG_MODE_TAG;
 		else
@@ -1201,7 +1731,7 @@ ar8327_vtu_load_vlan(struct ar8216_priv 
 }
 
 static void
-ar8327_setup_port(struct ar8216_priv *priv, int port, u32 egress, u32 ingress,
+ar8327_setup_port(struct ar8xxx_priv *priv, int port, u32 egress, u32 ingress,
 		  u32 members, u32 pvid)
 {
 	u32 t;
@@ -1238,6 +1768,7 @@ ar8327_setup_port(struct ar8216_priv *pr
 static const struct ar8xxx_chip ar8327_chip = {
 	.caps = AR8XXX_CAP_GIGE | AR8XXX_CAP_MIB_COUNTERS,
 	.hw_init = ar8327_hw_init,
+	.cleanup = ar8327_cleanup,
 	.init_globals = ar8327_init_globals,
 	.init_port = ar8327_init_port,
 	.setup_port = ar8327_setup_port,
@@ -1251,28 +1782,28 @@ static const struct ar8xxx_chip ar8327_c
 };
 
 static int
-ar8216_sw_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+ar8xxx_sw_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
 		   struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	priv->vlan = !!val->value.i;
 	return 0;
 }
 
 static int
-ar8216_sw_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+ar8xxx_sw_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
 		   struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	val->value.i = priv->vlan;
 	return 0;
 }
 
 
 static int
-ar8216_sw_set_pvid(struct switch_dev *dev, int port, int vlan)
+ar8xxx_sw_set_pvid(struct switch_dev *dev, int port, int vlan)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 
 	/* make sure no invalid PVIDs get set */
 
@@ -1284,45 +1815,45 @@ ar8216_sw_set_pvid(struct switch_dev *de
 }
 
 static int
-ar8216_sw_get_pvid(struct switch_dev *dev, int port, int *vlan)
+ar8xxx_sw_get_pvid(struct switch_dev *dev, int port, int *vlan)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	*vlan = priv->pvid[port];
 	return 0;
 }
 
 static int
-ar8216_sw_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+ar8xxx_sw_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
 		  struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	priv->vlan_id[val->port_vlan] = val->value.i;
 	return 0;
 }
 
 static int
-ar8216_sw_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+ar8xxx_sw_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
 		  struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	val->value.i = priv->vlan_id[val->port_vlan];
 	return 0;
 }
 
 static int
-ar8216_sw_get_port_link(struct switch_dev *dev, int port,
+ar8xxx_sw_get_port_link(struct switch_dev *dev, int port,
 			struct switch_port_link *link)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 
 	ar8216_read_port_link(priv, port, link);
 	return 0;
 }
 
 static int
-ar8216_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
+ar8xxx_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	u8 ports = priv->vlan_table[val->port_vlan];
 	int i;
 
@@ -1344,9 +1875,9 @@ ar8216_sw_get_ports(struct switch_dev *d
 }
 
 static int
-ar8216_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
+ar8xxx_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	u8 *vt = &priv->vlan_table[val->port_vlan];
 	int i, j;
 
@@ -1374,10 +1905,102 @@ ar8216_sw_set_ports(struct switch_dev *d
 	return 0;
 }
 
+static void
+ar8327_set_mirror_regs(struct ar8xxx_priv *priv)
+{
+	int port;
+
+	/* reset all mirror registers */
+	ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
+		   AR8327_FWD_CTRL0_MIRROR_PORT,
+		   (0xF << AR8327_FWD_CTRL0_MIRROR_PORT_S));
+	for (port = 0; port < AR8327_NUM_PORTS; port++) {
+		ar8xxx_rmw(priv, AR8327_REG_PORT_LOOKUP(port),
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN,
+			   0);
+
+		ar8xxx_rmw(priv, AR8327_REG_PORT_HOL_CTRL1(port),
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN,
+			   0);
+	}
+
+	/* now enable mirroring if necessary */
+	if (priv->source_port >= AR8327_NUM_PORTS ||
+	    priv->monitor_port >= AR8327_NUM_PORTS ||
+	    priv->source_port == priv->monitor_port) {
+		return;
+	}
+
+	ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
+		   AR8327_FWD_CTRL0_MIRROR_PORT,
+		   (priv->monitor_port << AR8327_FWD_CTRL0_MIRROR_PORT_S));
+
+	if (priv->mirror_rx)
+		ar8xxx_rmw(priv, AR8327_REG_PORT_LOOKUP(priv->source_port),
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN,
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN);
+
+	if (priv->mirror_tx)
+		ar8xxx_rmw(priv, AR8327_REG_PORT_HOL_CTRL1(priv->source_port),
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN,
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN);
+}
+
+static void
+ar8216_set_mirror_regs(struct ar8xxx_priv *priv)
+{
+	int port;
+
+	/* reset all mirror registers */
+	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CPUPORT,
+		   AR8216_GLOBAL_CPUPORT_MIRROR_PORT,
+		   (0xF << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
+	for (port = 0; port < AR8216_NUM_PORTS; port++) {
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
+			   AR8216_PORT_CTRL_MIRROR_RX,
+			   0);
+
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
+			   AR8216_PORT_CTRL_MIRROR_TX,
+			   0);
+	}
+
+	/* now enable mirroring if necessary */
+	if (priv->source_port >= AR8216_NUM_PORTS ||
+	    priv->monitor_port >= AR8216_NUM_PORTS ||
+	    priv->source_port == priv->monitor_port) {
+		return;
+	}
+
+	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CPUPORT,
+		   AR8216_GLOBAL_CPUPORT_MIRROR_PORT,
+		   (priv->monitor_port << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
+
+	if (priv->mirror_rx)
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+			   AR8216_PORT_CTRL_MIRROR_RX,
+			   AR8216_PORT_CTRL_MIRROR_RX);
+
+	if (priv->mirror_tx)
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+			   AR8216_PORT_CTRL_MIRROR_TX,
+			   AR8216_PORT_CTRL_MIRROR_TX);
+}
+
+static void
+ar8xxx_set_mirror_regs(struct ar8xxx_priv *priv)
+{
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv)) {
+		ar8327_set_mirror_regs(priv);
+	} else {
+		ar8216_set_mirror_regs(priv);
+	}
+}
+
 static int
-ar8216_sw_hw_apply(struct switch_dev *dev)
+ar8xxx_sw_hw_apply(struct switch_dev *dev)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	u8 portmask[AR8X16_MAX_PORTS];
 	int i, j;
 
@@ -1437,19 +2060,22 @@ ar8216_sw_hw_apply(struct switch_dev *de
 		priv->chip->setup_port(priv, i, egress, ingress, portmask[i],
 				       pvid);
 	}
+
+	ar8xxx_set_mirror_regs(priv);
+
 	mutex_unlock(&priv->reg_mutex);
 	return 0;
 }
 
 static int
-ar8216_sw_reset_switch(struct switch_dev *dev)
+ar8xxx_sw_reset_switch(struct switch_dev *dev)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	int i;
 
 	mutex_lock(&priv->reg_mutex);
-	memset(&priv->vlan, 0, sizeof(struct ar8216_priv) -
-		offsetof(struct ar8216_priv, vlan));
+	memset(&priv->vlan, 0, sizeof(struct ar8xxx_priv) -
+		offsetof(struct ar8xxx_priv, vlan));
 
 	for (i = 0; i < AR8X16_MAX_VLANS; i++)
 		priv->vlan_id[i] = i;
@@ -1458,18 +2084,24 @@ ar8216_sw_reset_switch(struct switch_dev
 	for (i = 0; i < dev->ports; i++)
 		priv->chip->init_port(priv, i);
 
+	priv->mirror_rx = false;
+	priv->mirror_tx = false;
+	priv->source_port = 0;
+	priv->monitor_port = 0;
+
 	priv->chip->init_globals(priv);
+
 	mutex_unlock(&priv->reg_mutex);
 
-	return ar8216_sw_hw_apply(dev);
+	return ar8xxx_sw_hw_apply(dev);
 }
 
 static int
-ar8216_sw_set_reset_mibs(struct switch_dev *dev,
+ar8xxx_sw_set_reset_mibs(struct switch_dev *dev,
 			 const struct switch_attr *attr,
 			 struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	unsigned int len;
 	int ret;
 
@@ -1481,7 +2113,7 @@ ar8216_sw_set_reset_mibs(struct switch_d
 	len = priv->dev.ports * priv->chip->num_mibs *
 	      sizeof(*priv->mib_stats);
 	memset(priv->mib_stats, '\0', len);
-	ret = ar8216_mib_flush(priv);
+	ret = ar8xxx_mib_flush(priv);
 	if (ret)
 		goto unlock;
 
@@ -1493,11 +2125,111 @@ unlock:
 }
 
 static int
-ar8216_sw_set_port_reset_mib(struct switch_dev *dev,
+ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	mutex_lock(&priv->reg_mutex);
+	priv->mirror_rx = !!val->value.i;
+	ar8xxx_set_mirror_regs(priv);
+	mutex_unlock(&priv->reg_mutex);
+
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_mirror_rx_enable(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	val->value.i = priv->mirror_rx;
+	return 0;
+}
+
+static int
+ar8xxx_sw_set_mirror_tx_enable(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	mutex_lock(&priv->reg_mutex);
+	priv->mirror_tx = !!val->value.i;
+	ar8xxx_set_mirror_regs(priv);
+	mutex_unlock(&priv->reg_mutex);
+
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_mirror_tx_enable(struct switch_dev *dev,
+			       const struct switch_attr *attr,
+			       struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	val->value.i = priv->mirror_tx;
+	return 0;
+}
+
+static int
+ar8xxx_sw_set_mirror_monitor_port(struct switch_dev *dev,
+				  const struct switch_attr *attr,
+				  struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	mutex_lock(&priv->reg_mutex);
+	priv->monitor_port = val->value.i;
+	ar8xxx_set_mirror_regs(priv);
+	mutex_unlock(&priv->reg_mutex);
+
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_mirror_monitor_port(struct switch_dev *dev,
+				  const struct switch_attr *attr,
+				  struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	val->value.i = priv->monitor_port;
+	return 0;
+}
+
+static int
+ar8xxx_sw_set_mirror_source_port(struct switch_dev *dev,
+				 const struct switch_attr *attr,
+				 struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	mutex_lock(&priv->reg_mutex);
+	priv->source_port = val->value.i;
+	ar8xxx_set_mirror_regs(priv);
+	mutex_unlock(&priv->reg_mutex);
+
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_mirror_source_port(struct switch_dev *dev,
+				 const struct switch_attr *attr,
+				 struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	val->value.i = priv->source_port;
+	return 0;
+}
+
+static int
+ar8xxx_sw_set_port_reset_mib(struct switch_dev *dev,
 			     const struct switch_attr *attr,
 			     struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	int port;
 	int ret;
 
@@ -1509,11 +2241,11 @@ ar8216_sw_set_port_reset_mib(struct swit
 		return -EINVAL;
 
 	mutex_lock(&priv->mib_lock);
-	ret = ar8216_mib_capture(priv);
+	ret = ar8xxx_mib_capture(priv);
 	if (ret)
 		goto unlock;
 
-	ar8216_mib_fetch_port_stat(priv, port, true);
+	ar8xxx_mib_fetch_port_stat(priv, port, true);
 
 	ret = 0;
 
@@ -1523,11 +2255,11 @@ unlock:
 }
 
 static int
-ar8216_sw_get_port_mib(struct switch_dev *dev,
+ar8xxx_sw_get_port_mib(struct switch_dev *dev,
 		       const struct switch_attr *attr,
 		       struct switch_val *val)
 {
-	struct ar8216_priv *priv = to_ar8216(dev);
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	const struct ar8xxx_chip *chip = priv->chip;
 	u64 *mib_stats;
 	int port;
@@ -1543,11 +2275,11 @@ ar8216_sw_get_port_mib(struct switch_dev
 		return -EINVAL;
 
 	mutex_lock(&priv->mib_lock);
-	ret = ar8216_mib_capture(priv);
+	ret = ar8xxx_mib_capture(priv);
 	if (ret)
 		goto unlock;
 
-	ar8216_mib_fetch_port_stat(priv, port, false);
+	ar8xxx_mib_fetch_port_stat(priv, port, false);
 
 	len += snprintf(buf + len, sizeof(priv->buf) - len,
 			"Port %d MIB counters\n",
@@ -1570,81 +2302,183 @@ unlock:
 	return ret;
 }
 
-static struct switch_attr ar8216_globals[] = {
+static struct switch_attr ar8xxx_sw_attr_globals[] = {
 	{
 		.type = SWITCH_TYPE_INT,
 		.name = "enable_vlan",
 		.description = "Enable VLAN mode",
-		.set = ar8216_sw_set_vlan,
-		.get = ar8216_sw_get_vlan,
+		.set = ar8xxx_sw_set_vlan,
+		.get = ar8xxx_sw_get_vlan,
 		.max = 1
 	},
 	{
 		.type = SWITCH_TYPE_NOVAL,
 		.name = "reset_mibs",
 		.description = "Reset all MIB counters",
-		.set = ar8216_sw_set_reset_mibs,
+		.set = ar8xxx_sw_set_reset_mibs,
 	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_rx",
+		.description = "Enable mirroring of RX packets",
+		.set = ar8xxx_sw_set_mirror_rx_enable,
+		.get = ar8xxx_sw_get_mirror_rx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_tx",
+		.description = "Enable mirroring of TX packets",
+		.set = ar8xxx_sw_set_mirror_tx_enable,
+		.get = ar8xxx_sw_get_mirror_tx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_monitor_port",
+		.description = "Mirror monitor port",
+		.set = ar8xxx_sw_set_mirror_monitor_port,
+		.get = ar8xxx_sw_get_mirror_monitor_port,
+		.max = AR8216_NUM_PORTS - 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_source_port",
+		.description = "Mirror source port",
+		.set = ar8xxx_sw_set_mirror_source_port,
+		.get = ar8xxx_sw_get_mirror_source_port,
+		.max = AR8216_NUM_PORTS - 1
+ 	},
+};
 
+static struct switch_attr ar8327_sw_attr_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar8xxx_sw_set_vlan,
+		.get = ar8xxx_sw_get_vlan,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mibs",
+		.description = "Reset all MIB counters",
+		.set = ar8xxx_sw_set_reset_mibs,
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_rx",
+		.description = "Enable mirroring of RX packets",
+		.set = ar8xxx_sw_set_mirror_rx_enable,
+		.get = ar8xxx_sw_get_mirror_rx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_tx",
+		.description = "Enable mirroring of TX packets",
+		.set = ar8xxx_sw_set_mirror_tx_enable,
+		.get = ar8xxx_sw_get_mirror_tx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_monitor_port",
+		.description = "Mirror monitor port",
+		.set = ar8xxx_sw_set_mirror_monitor_port,
+		.get = ar8xxx_sw_get_mirror_monitor_port,
+		.max = AR8327_NUM_PORTS - 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_source_port",
+		.description = "Mirror source port",
+		.set = ar8xxx_sw_set_mirror_source_port,
+		.get = ar8xxx_sw_get_mirror_source_port,
+		.max = AR8327_NUM_PORTS - 1
+ 	},
 };
 
-static struct switch_attr ar8216_port[] = {
+static struct switch_attr ar8xxx_sw_attr_port[] = {
 	{
 		.type = SWITCH_TYPE_NOVAL,
 		.name = "reset_mib",
 		.description = "Reset single port MIB counters",
-		.set = ar8216_sw_set_port_reset_mib,
+		.set = ar8xxx_sw_set_port_reset_mib,
 	},
 	{
 		.type = SWITCH_TYPE_STRING,
 		.name = "mib",
 		.description = "Get port's MIB counters",
 		.set = NULL,
-		.get = ar8216_sw_get_port_mib,
+		.get = ar8xxx_sw_get_port_mib,
 	},
 };
 
-static struct switch_attr ar8216_vlan[] = {
+static struct switch_attr ar8xxx_sw_attr_vlan[] = {
 	{
 		.type = SWITCH_TYPE_INT,
 		.name = "vid",
 		.description = "VLAN ID (0-4094)",
-		.set = ar8216_sw_set_vid,
-		.get = ar8216_sw_get_vid,
+		.set = ar8xxx_sw_set_vid,
+		.get = ar8xxx_sw_get_vid,
 		.max = 4094,
 	},
 };
 
-static const struct switch_dev_ops ar8216_sw_ops = {
+static const struct switch_dev_ops ar8xxx_sw_ops = {
+	.attr_global = {
+		.attr = ar8xxx_sw_attr_globals,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_globals),
+	},
+	.attr_port = {
+		.attr = ar8xxx_sw_attr_port,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_port),
+	},
+	.attr_vlan = {
+		.attr = ar8xxx_sw_attr_vlan,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_vlan),
+	},
+	.get_port_pvid = ar8xxx_sw_get_pvid,
+	.set_port_pvid = ar8xxx_sw_set_pvid,
+	.get_vlan_ports = ar8xxx_sw_get_ports,
+	.set_vlan_ports = ar8xxx_sw_set_ports,
+	.apply_config = ar8xxx_sw_hw_apply,
+	.reset_switch = ar8xxx_sw_reset_switch,
+	.get_port_link = ar8xxx_sw_get_port_link,
+};
+
+static const struct switch_dev_ops ar8327_sw_ops = {
 	.attr_global = {
-		.attr = ar8216_globals,
-		.n_attr = ARRAY_SIZE(ar8216_globals),
+		.attr = ar8327_sw_attr_globals,
+		.n_attr = ARRAY_SIZE(ar8327_sw_attr_globals),
 	},
 	.attr_port = {
-		.attr = ar8216_port,
-		.n_attr = ARRAY_SIZE(ar8216_port),
+		.attr = ar8xxx_sw_attr_port,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_port),
 	},
 	.attr_vlan = {
-		.attr = ar8216_vlan,
-		.n_attr = ARRAY_SIZE(ar8216_vlan),
+		.attr = ar8xxx_sw_attr_vlan,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_vlan),
 	},
-	.get_port_pvid = ar8216_sw_get_pvid,
-	.set_port_pvid = ar8216_sw_set_pvid,
-	.get_vlan_ports = ar8216_sw_get_ports,
-	.set_vlan_ports = ar8216_sw_set_ports,
-	.apply_config = ar8216_sw_hw_apply,
-	.reset_switch = ar8216_sw_reset_switch,
-	.get_port_link = ar8216_sw_get_port_link,
+	.get_port_pvid = ar8xxx_sw_get_pvid,
+	.set_port_pvid = ar8xxx_sw_set_pvid,
+	.get_vlan_ports = ar8xxx_sw_get_ports,
+	.set_vlan_ports = ar8xxx_sw_set_ports,
+	.apply_config = ar8xxx_sw_hw_apply,
+	.reset_switch = ar8xxx_sw_reset_switch,
+	.get_port_link = ar8xxx_sw_get_port_link,
 };
 
 static int
-ar8216_id_chip(struct ar8216_priv *priv)
+ar8xxx_id_chip(struct ar8xxx_priv *priv)
 {
 	u32 val;
 	u16 id;
 	int i;
 
-	val = ar8216_mii_read(priv, AR8216_REG_CTRL);
+	val = priv->read(priv, AR8216_REG_CTRL);
 	if (val == ~0)
 		return -ENODEV;
 
@@ -1652,7 +2486,7 @@ ar8216_id_chip(struct ar8216_priv *priv)
 	for (i = 0; i < AR8X16_PROBE_RETRIES; i++) {
 		u16 t;
 
-		val = ar8216_mii_read(priv, AR8216_REG_CTRL);
+		val = priv->read(priv, AR8216_REG_CTRL);
 		if (val == ~0)
 			return -ENODEV;
 
@@ -1678,12 +2512,13 @@ ar8216_id_chip(struct ar8216_priv *priv)
 		priv->mii_lo_first = true;
 		priv->chip = &ar8327_chip;
 		break;
+	case AR8XXX_VER_AR8337:
+		priv->mii_lo_first = true;
+		priv->chip = &ar8327_chip;
+		break;
 	default:
-		printk(KERN_DEBUG
-			"ar8216: Unknown Atheros device [ver=%d, rev=%d, phy_id=%04x%04x]\n",
-			priv->chip_ver, priv->chip_rev,
-			mdiobus_read(priv->phy->bus, priv->phy->addr, 2),
-			mdiobus_read(priv->phy->bus, priv->phy->addr, 3));
+		pr_err("ar8216: Unknown Atheros device [ver=%d, rev=%d]\n",
+		       priv->chip_ver, priv->chip_rev);
 
 		return -ENODEV;
 	}
@@ -1694,18 +2529,18 @@ ar8216_id_chip(struct ar8216_priv *priv)
 static void
 ar8xxx_mib_work_func(struct work_struct *work)
 {
-	struct ar8216_priv *priv;
+	struct ar8xxx_priv *priv;
 	int err;
 
-	priv = container_of(work, struct ar8216_priv, mib_work.work);
+	priv = container_of(work, struct ar8xxx_priv, mib_work.work);
 
 	mutex_lock(&priv->mib_lock);
 
-	err = ar8216_mib_capture(priv);
+	err = ar8xxx_mib_capture(priv);
 	if (err)
 		goto next_port;
 
-	ar8216_mib_fetch_port_stat(priv, priv->mib_next_port, false);
+	ar8xxx_mib_fetch_port_stat(priv, priv->mib_next_port, false);
 
 next_port:
 	priv->mib_next_port++;
@@ -1718,7 +2553,7 @@ next_port:
 }
 
 static int
-ar8xxx_mib_init(struct ar8216_priv *priv)
+ar8xxx_mib_init(struct ar8xxx_priv *priv)
 {
 	unsigned int len;
 
@@ -1734,14 +2569,11 @@ ar8xxx_mib_init(struct ar8216_priv *priv
 	if (!priv->mib_stats)
 		return -ENOMEM;
 
-	mutex_init(&priv->mib_lock);
-	INIT_DELAYED_WORK(&priv->mib_work, ar8xxx_mib_work_func);
-
 	return 0;
 }
 
 static void
-ar8xxx_mib_start(struct ar8216_priv *priv)
+ar8xxx_mib_start(struct ar8xxx_priv *priv)
 {
 	if (!ar8xxx_has_mib_counters(priv))
 		return;
@@ -1751,96 +2583,74 @@ ar8xxx_mib_start(struct ar8216_priv *pri
 }
 
 static void
-ar8xxx_mib_cleanup(struct ar8216_priv *priv)
+ar8xxx_mib_stop(struct ar8xxx_priv *priv)
 {
 	if (!ar8xxx_has_mib_counters(priv))
 		return;
 
 	cancel_delayed_work(&priv->mib_work);
-	kfree(priv->mib_stats);
 }
 
-static int
-ar8216_config_init(struct phy_device *pdev)
+static struct ar8xxx_priv *
+ar8xxx_create(void)
 {
-	struct ar8216_priv *priv = pdev->priv;
-	struct net_device *dev = pdev->attached_dev;
-	struct switch_dev *swdev;
-	int ret;
-
-	if (!priv) {
-		priv = kzalloc(sizeof(struct ar8216_priv), GFP_KERNEL);
-		if (priv == NULL)
-			return -ENOMEM;
-	}
+	struct ar8xxx_priv *priv;
 
-	priv->phy = pdev;
-
-	ret = ar8216_id_chip(priv);
-	if (ret)
-		goto err_free_priv;
+	priv = kzalloc(sizeof(struct ar8xxx_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
 
-	if (pdev->addr != 0) {
-		if (ar8xxx_has_gige(priv)) {
-			pdev->supported |= SUPPORTED_1000baseT_Full;
-			pdev->advertising |= ADVERTISED_1000baseT_Full;
-		}
+	mutex_init(&priv->reg_mutex);
+	mutex_init(&priv->mib_lock);
+	INIT_DELAYED_WORK(&priv->mib_work, ar8xxx_mib_work_func);
 
-		if (chip_is_ar8316(priv)) {
-			/* check if we're attaching to the switch twice */
-			pdev = pdev->bus->phy_map[0];
-			if (!pdev) {
-				kfree(priv);
-				return 0;
-			}
+	return priv;
+}
 
-			/* switch device has not been initialized, reuse priv */
-			if (!pdev->priv) {
-				priv->port4_phy = true;
-				pdev->priv = priv;
-				return 0;
-			}
+static void
+ar8xxx_free(struct ar8xxx_priv *priv)
+{
+	if (priv->chip && priv->chip->cleanup)
+		priv->chip->cleanup(priv);
 
-			kfree(priv);
+	kfree(priv->mib_stats);
+	kfree(priv);
+}
 
-			/* switch device has been initialized, reinit */
-			priv = pdev->priv;
-			priv->dev.ports = (AR8216_NUM_PORTS - 1);
-			priv->initialized = false;
-			priv->port4_phy = true;
-			ar8316_hw_init(priv);
-			return 0;
-		}
+static struct ar8xxx_priv *
+ar8xxx_create_mii(struct mii_bus *bus)
+{
+	struct ar8xxx_priv *priv;
 
-		kfree(priv);
-		return 0;
+	priv = ar8xxx_create();
+	if (priv) {
+		priv->mii_bus = bus;
+		priv->read = ar8xxx_mii_read;
+		priv->write = ar8xxx_mii_write;
+		priv->rmw = ar8xxx_mii_rmw;
 	}
 
-	if (ar8xxx_has_gige(priv))
-		pdev->supported = SUPPORTED_1000baseT_Full;
-	else
-		pdev->supported = SUPPORTED_100baseT_Full;
-	pdev->advertising = pdev->supported;
+	return priv;
+}
 
-	mutex_init(&priv->reg_mutex);
-	priv->read = ar8216_mii_read;
-	priv->write = ar8216_mii_write;
+static int
+ar8xxx_probe_switch(struct ar8xxx_priv *priv)
+{
+	struct switch_dev *swdev;
+	int ret;
 
-	pdev->priv = priv;
+	ret = ar8xxx_id_chip(priv);
+	if (ret)
+		return ret;
 
 	swdev = &priv->dev;
 	swdev->cpu_port = AR8216_PORT_CPU;
-	swdev->ops = &ar8216_sw_ops;
-	swdev->ports = AR8216_NUM_PORTS;
+	swdev->ops = &ar8xxx_sw_ops;
 
 	if (chip_is_ar8316(priv)) {
 		swdev->name = "Atheros AR8316";
 		swdev->vlans = AR8X16_MAX_VLANS;
-
-		if (priv->port4_phy) {
-			/* port 5 connected to the other mac, therefore unusable */
-			swdev->ports = (AR8216_NUM_PORTS - 1);
-		}
+		swdev->ports = AR8216_NUM_PORTS;
 	} else if (chip_is_ar8236(priv)) {
 		swdev->name = "Atheros AR8236";
 		swdev->vlans = AR8216_NUM_VLANS;
@@ -1849,58 +2659,94 @@ ar8216_config_init(struct phy_device *pd
 		swdev->name = "Atheros AR8327";
 		swdev->vlans = AR8X16_MAX_VLANS;
 		swdev->ports = AR8327_NUM_PORTS;
+		swdev->ops = &ar8327_sw_ops;
+	} else if (chip_is_ar8337(priv)) {
+		swdev->name = "Atheros AR8337";
+		swdev->vlans = AR8X16_MAX_VLANS;
+		swdev->ports = AR8327_NUM_PORTS;
+		swdev->ops = &ar8327_sw_ops;
 	} else {
 		swdev->name = "Atheros AR8216";
 		swdev->vlans = AR8216_NUM_VLANS;
+		swdev->ports = AR8216_NUM_PORTS;
 	}
 
 	ret = ar8xxx_mib_init(priv);
 	if (ret)
-		goto err_free_priv;
+		return ret;
 
-	ret = register_switch(&priv->dev, pdev->attached_dev);
-	if (ret)
-		goto err_cleanup_mib;
+	return 0;
+}
 
-	printk(KERN_INFO "%s: %s switch driver attached.\n",
-		pdev->attached_dev->name, swdev->name);
+static int
+ar8xxx_start(struct ar8xxx_priv *priv)
+{
+	int ret;
 
 	priv->init = true;
 
 	ret = priv->chip->hw_init(priv);
 	if (ret)
-		goto err_cleanup_mib;
+		return ret;
 
-	ret = ar8216_sw_reset_switch(&priv->dev);
+	ret = ar8xxx_sw_reset_switch(&priv->dev);
 	if (ret)
-		goto err_cleanup_mib;
+		return ret;
 
-	dev->phy_ptr = priv;
+	priv->init = false;
+
+	ar8xxx_mib_start(priv);
+
+	return 0;
+}
+
+static int
+ar8xxx_phy_config_init(struct phy_device *phydev)
+{
+	struct ar8xxx_priv *priv = phydev->priv;
+	struct net_device *dev = phydev->attached_dev;
+	int ret;
+
+	if (WARN_ON(!priv))
+		return -ENODEV;
+
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv))
+		return 0;
+
+	priv->phy = phydev;
+
+	if (phydev->addr != 0) {
+		if (chip_is_ar8316(priv)) {
+			/* switch device has been initialized, reinit */
+			priv->dev.ports = (AR8216_NUM_PORTS - 1);
+			priv->initialized = false;
+			priv->port4_phy = true;
+			ar8316_hw_init(priv);
+			return 0;
+		}
+
+		return 0;
+	}
+
+	ret = ar8xxx_start(priv);
+	if (ret)
+		return ret;
 
 	/* VID fixup only needed on ar8216 */
-	if (chip_is_ar8216(priv) && pdev->addr == 0) {
+	if (chip_is_ar8216(priv)) {
+		dev->phy_ptr = priv;
 		dev->priv_flags |= IFF_NO_IP_ALIGN;
 		dev->eth_mangle_rx = ar8216_mangle_rx;
 		dev->eth_mangle_tx = ar8216_mangle_tx;
 	}
 
-	priv->init = false;
-
-	ar8xxx_mib_start(priv);
-
 	return 0;
-
-err_cleanup_mib:
-	ar8xxx_mib_cleanup(priv);
-err_free_priv:
-	kfree(priv);
-	return ret;
 }
 
 static int
-ar8216_read_status(struct phy_device *phydev)
+ar8xxx_phy_read_status(struct phy_device *phydev)
 {
-	struct ar8216_priv *priv = phydev->priv;
+	struct ar8xxx_priv *priv = phydev->priv;
 	struct switch_port_link link;
 	int ret;
 
@@ -1940,7 +2786,7 @@ ar8216_read_status(struct phy_device *ph
 }
 
 static int
-ar8216_config_aneg(struct phy_device *phydev)
+ar8xxx_phy_config_aneg(struct phy_device *phydev)
 {
 	if (phydev->addr == 0)
 		return 0;
@@ -1948,70 +2794,195 @@ ar8216_config_aneg(struct phy_device *ph
 	return genphy_config_aneg(phydev);
 }
 
+static const u32 ar8xxx_phy_ids[] = {
+	0x004dd033,
+	0x004dd034, /* AR8327 */
+	0x004dd036, /* AR8337 */
+	0x004dd041,
+	0x004dd042,
+	0x004dd043, /* AR8236 */
+};
+
+static bool
+ar8xxx_phy_match(u32 phy_id)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ar8xxx_phy_ids); i++)
+		if (phy_id == ar8xxx_phy_ids[i])
+			return true;
+
+	return false;
+}
+
+static bool
+ar8xxx_is_possible(struct mii_bus *bus)
+{
+	unsigned i;
+
+	for (i = 0; i < 4; i++) {
+		u32 phy_id;
+
+		phy_id = mdiobus_read(bus, i, MII_PHYSID1) << 16;
+		phy_id |= mdiobus_read(bus, i, MII_PHYSID2);
+		if (!ar8xxx_phy_match(phy_id)) {
+			pr_debug("ar8xxx: unknown PHY at %s:%02x id:%08x\n",
+				 dev_name(&bus->dev), i, phy_id);
+			return false;
+		}
+	}
+
+	return true;
+}
+
 static int
-ar8216_probe(struct phy_device *pdev)
+ar8xxx_phy_probe(struct phy_device *phydev)
 {
-	struct ar8216_priv *priv;
+	struct ar8xxx_priv *priv;
+	struct switch_dev *swdev;
 	int ret;
 
-	priv = kzalloc(sizeof(struct ar8216_priv), GFP_KERNEL);
-	if (priv == NULL)
-		return -ENOMEM;
+	/* skip PHYs at unused adresses */
+	if (phydev->addr != 0 && phydev->addr != 4)
+		return -ENODEV;
 
-	priv->phy = pdev;
+	if (!ar8xxx_is_possible(phydev->bus))
+		return -ENODEV;
 
-	ret = ar8216_id_chip(priv);
-	kfree(priv);
+	mutex_lock(&ar8xxx_dev_list_lock);
+	list_for_each_entry(priv, &ar8xxx_dev_list, list)
+		if (priv->mii_bus == phydev->bus)
+			goto found;
+
+	priv = ar8xxx_create_mii(phydev->bus);
+	if (priv == NULL) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+
+	ret = ar8xxx_probe_switch(priv);
+	if (ret)
+		goto free_priv;
+
+	swdev = &priv->dev;
+	swdev->alias = dev_name(&priv->mii_bus->dev);
+	ret = register_switch(swdev, NULL);
+	if (ret)
+		goto free_priv;
+
+	pr_info("%s: %s rev. %u switch registered on %s\n",
+		swdev->devname, swdev->name, priv->chip_rev,
+		dev_name(&priv->mii_bus->dev));
 
+found:
+	priv->use_count++;
+
+	if (phydev->addr == 0) {
+		if (ar8xxx_has_gige(priv)) {
+			phydev->supported = SUPPORTED_1000baseT_Full;
+			phydev->advertising = ADVERTISED_1000baseT_Full;
+		} else {
+			phydev->supported = SUPPORTED_100baseT_Full;
+			phydev->advertising = ADVERTISED_100baseT_Full;
+		}
+
+		if (chip_is_ar8327(priv) || chip_is_ar8337(priv)) {
+			priv->phy = phydev;
+
+			ret = ar8xxx_start(priv);
+			if (ret)
+				goto err_unregister_switch;
+		}
+	} else {
+		if (ar8xxx_has_gige(priv)) {
+			phydev->supported |= SUPPORTED_1000baseT_Full;
+			phydev->advertising |= ADVERTISED_1000baseT_Full;
+		}
+	}
+
+	phydev->priv = priv;
+
+	list_add(&priv->list, &ar8xxx_dev_list);
+
+	mutex_unlock(&ar8xxx_dev_list_lock);
+
+	return 0;
+
+err_unregister_switch:
+	if (--priv->use_count)
+		goto unlock;
+
+	unregister_switch(&priv->dev);
+
+free_priv:
+	ar8xxx_free(priv);
+unlock:
+	mutex_unlock(&ar8xxx_dev_list_lock);
 	return ret;
 }
 
 static void
-ar8216_remove(struct phy_device *pdev)
+ar8xxx_phy_detach(struct phy_device *phydev)
 {
-	struct ar8216_priv *priv = pdev->priv;
-	struct net_device *dev = pdev->attached_dev;
+	struct net_device *dev = phydev->attached_dev;
 
-	if (!priv)
+	if (!dev)
 		return;
 
+	dev->phy_ptr = NULL;
 	dev->priv_flags &= ~IFF_NO_IP_ALIGN;
 	dev->eth_mangle_rx = NULL;
 	dev->eth_mangle_tx = NULL;
+}
 
-	if (pdev->addr == 0)
-		unregister_switch(&priv->dev);
+static void
+ar8xxx_phy_remove(struct phy_device *phydev)
+{
+	struct ar8xxx_priv *priv = phydev->priv;
 
-	ar8xxx_mib_cleanup(priv);
-	kfree(priv);
+	if (WARN_ON(!priv))
+		return;
+
+	phydev->priv = NULL;
+	if (--priv->use_count > 0)
+		return;
+
+	mutex_lock(&ar8xxx_dev_list_lock);
+	list_del(&priv->list);
+	mutex_unlock(&ar8xxx_dev_list_lock);
+
+	unregister_switch(&priv->dev);
+	ar8xxx_mib_stop(priv);
+	ar8xxx_free(priv);
 }
 
-static struct phy_driver ar8216_driver = {
+static struct phy_driver ar8xxx_phy_driver = {
 	.phy_id		= 0x004d0000,
 	.name		= "Atheros AR8216/AR8236/AR8316",
 	.phy_id_mask	= 0xffff0000,
 	.features	= PHY_BASIC_FEATURES,
-	.probe		= ar8216_probe,
-	.remove		= ar8216_remove,
-	.config_init	= &ar8216_config_init,
-	.config_aneg	= &ar8216_config_aneg,
-	.read_status	= &ar8216_read_status,
+	.probe		= ar8xxx_phy_probe,
+	.remove		= ar8xxx_phy_remove,
+	.detach		= ar8xxx_phy_detach,
+	.config_init	= ar8xxx_phy_config_init,
+	.config_aneg	= ar8xxx_phy_config_aneg,
+	.read_status	= ar8xxx_phy_read_status,
 	.driver		= { .owner = THIS_MODULE },
 };
 
 int __init
-ar8216_init(void)
+ar8xxx_init(void)
 {
-	return phy_driver_register(&ar8216_driver);
+	return phy_driver_register(&ar8xxx_phy_driver);
 }
 
 void __exit
-ar8216_exit(void)
+ar8xxx_exit(void)
 {
-	phy_driver_unregister(&ar8216_driver);
+	phy_driver_unregister(&ar8xxx_phy_driver);
 }
 
-module_init(ar8216_init);
-module_exit(ar8216_exit);
+module_init(ar8xxx_init);
+module_exit(ar8xxx_exit);
 MODULE_LICENSE("GPL");
 
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/drivers/net/phy/ar8216.h attitude_adjustment WD/target/linux/generic/files/drivers/net/phy/ar8216.h
--- attitude_adjustment/target/linux/generic/files/drivers/net/phy/ar8216.h	2014-04-17 00:00:00.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/files/drivers/net/phy/ar8216.h	2014-04-18 08:13:06.000000000 -0400
@@ -105,6 +105,10 @@
 #define   AR8216_MIB_FUNC_CAPTURE	0x3
 #define   AR8236_MIB_EN			BIT(30)
 
+#define AR8216_REG_GLOBAL_CPUPORT		0x0078
+#define   AR8216_GLOBAL_CPUPORT_MIRROR_PORT	BITS(4, 4)
+#define   AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S	4
+
 #define AR8216_PORT_OFFSET(_i)		(0x0100 * (_i + 1))
 #define AR8216_REG_PORT_STATUS(_i)	(AR8216_PORT_OFFSET(_i) + 0x0000)
 #define   AR8216_PORT_STATUS_SPEED	BITS(0,2)
@@ -255,9 +259,41 @@
 #define AR8236_STATS_TXDEFER		0xa0
 #define AR8236_STATS_TXLATECOL		0xa4
 
+#define AR8316_REG_POSTRIP			0x0008
+#define   AR8316_POSTRIP_MAC0_GMII_EN		BIT(0)
+#define   AR8316_POSTRIP_MAC0_RGMII_EN		BIT(1)
+#define   AR8316_POSTRIP_PHY4_GMII_EN		BIT(2)
+#define   AR8316_POSTRIP_PHY4_RGMII_EN		BIT(3)
+#define   AR8316_POSTRIP_MAC0_MAC_MODE		BIT(4)
+#define   AR8316_POSTRIP_RTL_MODE		BIT(5)
+#define   AR8316_POSTRIP_RGMII_RXCLK_DELAY_EN	BIT(6)
+#define   AR8316_POSTRIP_RGMII_TXCLK_DELAY_EN	BIT(7)
+#define   AR8316_POSTRIP_SERDES_EN		BIT(8)
+#define   AR8316_POSTRIP_SEL_ANA_RST		BIT(9)
+#define   AR8316_POSTRIP_GATE_25M_EN		BIT(10)
+#define   AR8316_POSTRIP_SEL_CLK25M		BIT(11)
+#define   AR8316_POSTRIP_HIB_PULSE_HW		BIT(12)
+#define   AR8316_POSTRIP_DBG_MODE_I		BIT(13)
+#define   AR8316_POSTRIP_MAC5_MAC_MODE		BIT(14)
+#define   AR8316_POSTRIP_MAC5_PHY_MODE		BIT(15)
+#define   AR8316_POSTRIP_POWER_DOWN_HW		BIT(16)
+#define   AR8316_POSTRIP_LPW_STATE_EN		BIT(17)
+#define   AR8316_POSTRIP_MAN_EN			BIT(18)
+#define   AR8316_POSTRIP_PHY_PLL_ON		BIT(19)
+#define   AR8316_POSTRIP_LPW_EXIT		BIT(20)
+#define   AR8316_POSTRIP_TXDELAY_S0		BIT(21)
+#define   AR8316_POSTRIP_TXDELAY_S1		BIT(22)
+#define   AR8316_POSTRIP_RXDELAY_S0		BIT(23)
+#define   AR8316_POSTRIP_LED_OPEN_EN		BIT(24)
+#define   AR8316_POSTRIP_SPI_EN			BIT(25)
+#define   AR8316_POSTRIP_RXDELAY_S1		BIT(26)
+#define   AR8316_POSTRIP_POWER_ON_SEL		BIT(31)
+
 #define AR8327_NUM_PORTS	7
+#define AR8327_NUM_LEDS		15
 #define AR8327_NUM_PHYS		5
 #define AR8327_PORTS_ALL	0x7f
+#define AR8327_NUM_LED_CTRL_REGS	4
 
 #define AR8327_REG_MASK				0x000
 
@@ -281,6 +317,7 @@
 #define   AR8327_PAD_PHYX_GMII_EN		BIT(16)
 #define   AR8327_PAD_PHYX_RGMII_EN		BIT(17)
 #define   AR8327_PAD_PHYX_MII_EN		BIT(18)
+#define   AR8327_PAD_SGMII_DELAY_EN		BIT(19)
 #define   AR8327_PAD_RGMII_RXCLK_DELAY_SEL	BITS(20, 2)
 #define   AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S	20
 #define   AR8327_PAD_RGMII_TXCLK_DELAY_SEL	BITS(22, 2)
@@ -292,6 +329,7 @@
 #define AR8327_REG_POWER_ON_STRIP		0x010
 #define   AR8327_POWER_ON_STRIP_POWER_ON_SEL	BIT(31)
 #define   AR8327_POWER_ON_STRIP_LED_OPEN_EN	BIT(24)
+#define   AR8327_POWER_ON_STRIP_SERDES_AEN	BIT(7)
 
 #define AR8327_REG_INT_STATUS0			0x020
 #define   AR8327_INT0_VT_DONE			BIT(20)
@@ -307,6 +345,7 @@
 #define   AR8327_MIB_CPU_KEEP			BIT(20)
 
 #define AR8327_REG_SERVICE_TAG			0x048
+#define AR8327_REG_LED_CTRL(_i)			(0x050 + (_i) * 4)
 #define AR8327_REG_LED_CTRL0			0x050
 #define AR8327_REG_LED_CTRL1			0x054
 #define AR8327_REG_LED_CTRL2			0x058
@@ -322,6 +361,14 @@
 #define AR8327_REG_HEADER_CTRL			0x098
 #define AR8327_REG_PORT_HEADER(_i)		(0x09c + (_i) * 4)
 
+#define AR8327_REG_SGMII_CTRL			0x0e0
+#define   AR8327_SGMII_CTRL_EN_PLL		BIT(1)
+#define   AR8327_SGMII_CTRL_EN_RX		BIT(2)
+#define   AR8327_SGMII_CTRL_EN_TX		BIT(3)
+
+#define AR8327_REG_EEE_CTRL			0x100
+#define   AR8327_EEE_CTRL_DISABLE_PHY(_i)	BIT(4 + (_i) * 2)
+
 #define AR8327_REG_PORT_VLAN0(_i)		(0x420 + (_i) * 0x8)
 #define   AR8327_PORT_VLAN0_DEF_SVID		BITS(0, 12)
 #define   AR8327_PORT_VLAN0_DEF_SVID_S		0
@@ -402,11 +449,17 @@
 #define   AR8327_PORT_LOOKUP_STATE		BITS(16, 3)
 #define   AR8327_PORT_LOOKUP_STATE_S		16
 #define   AR8327_PORT_LOOKUP_LEARN		BIT(20)
+#define   AR8327_PORT_LOOKUP_ING_MIRROR_EN	BIT(25)
 
 #define AR8327_REG_PORT_PRIO(_i)		(0x664 + (_i) * 0xc)
 
+#define AR8327_REG_PORT_HOL_CTRL1(_i)		(0x974 + (_i) * 0x8)
+#define   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN	BIT(16)
+
 #define AR8327_REG_PORT_STATS_BASE(_i)		(0x1000 + (_i) * 0x100)
 
+#define AR8337_PAD_MAC06_EXCHANGE_EN		BIT(31)
+
 /* port speed */
 enum {
         AR8216_PORT_SPEED_10M = 0,
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/files/include/linux/ar8216_platform.h attitude_adjustment WD/target/linux/generic/files/include/linux/ar8216_platform.h
--- attitude_adjustment/target/linux/generic/files/include/linux/ar8216_platform.h	2014-04-17 00:00:18.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/files/include/linux/ar8216_platform.h	2014-04-18 08:13:08.000000000 -0400
@@ -44,6 +44,7 @@ struct ar8327_pad_cfg {
 	bool pipe_rxclk_sel;
 	bool txclk_delay_en;
 	bool rxclk_delay_en;
+	bool sgmii_delay_en;
 	enum ar8327_clk_delay_sel txclk_delay_sel;
 	enum ar8327_clk_delay_sel rxclk_delay_sel;
 };
@@ -62,6 +63,11 @@ struct ar8327_port_cfg {
 	int duplex:1;
 };
 
+struct ar8327_sgmii_cfg {
+	u32 sgmii_ctrl;
+	bool serdes_aen;
+};
+
 struct ar8327_led_cfg {
 	u32 led_ctrl0;
 	u32 led_ctrl1;
@@ -70,12 +76,56 @@ struct ar8327_led_cfg {
 	bool open_drain;
 };
 
+enum ar8327_led_num {
+	AR8327_LED_PHY0_0 = 0,
+	AR8327_LED_PHY0_1,
+	AR8327_LED_PHY0_2,
+	AR8327_LED_PHY1_0,
+	AR8327_LED_PHY1_1,
+	AR8327_LED_PHY1_2,
+	AR8327_LED_PHY2_0,
+	AR8327_LED_PHY2_1,
+	AR8327_LED_PHY2_2,
+	AR8327_LED_PHY3_0,
+	AR8327_LED_PHY3_1,
+	AR8327_LED_PHY3_2,
+	AR8327_LED_PHY4_0,
+	AR8327_LED_PHY4_1,
+	AR8327_LED_PHY4_2,
+};
+
+enum ar8327_led_mode {
+	AR8327_LED_MODE_HW = 0,
+	AR8327_LED_MODE_SW,
+};
+
+struct ar8327_led_info {
+	const char *name;
+	const char *default_trigger;
+	bool active_low;
+	enum ar8327_led_num led_num;
+	enum ar8327_led_mode mode;
+};
+
+#define AR8327_LED_INFO(_led, _mode, _name) {	\
+	.name = (_name), 	   		\
+	.led_num = AR8327_LED_ ## _led,		\
+	.mode = AR8327_LED_MODE_ ## _mode 	\
+}
+
 struct ar8327_platform_data {
 	struct ar8327_pad_cfg *pad0_cfg;
 	struct ar8327_pad_cfg *pad5_cfg;
 	struct ar8327_pad_cfg *pad6_cfg;
-	struct ar8327_port_cfg cpuport_cfg;
+	struct ar8327_sgmii_cfg *sgmii_cfg;
+	struct ar8327_port_cfg port0_cfg;
+	struct ar8327_port_cfg port6_cfg;
 	struct ar8327_led_cfg *led_cfg;
+
+	int (*get_port_link)(unsigned port);
+
+	unsigned num_leds;
+	const struct ar8327_led_info *leds;
 };
 
 #endif /* AR8216_PLATFORM_H */
\ No newline at end of file
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/400-mtd-add-rootfs-split-support.patch attitude_adjustment WD/target/linux/generic/patches-3.3/400-mtd-add-rootfs-split-support.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/400-mtd-add-rootfs-split-support.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/400-mtd-add-rootfs-split-support.patch	2014-04-20 18:22:41.000000000 -0400
@@ -0,0 +1,299 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -12,6 +12,32 @@ menuconfig MTD
+ 
+ if MTD
+ 
++menu "OpenWrt specific MTD options"
++
++config MTD_ROOTFS_ROOT_DEV
++	bool "Automatically set 'rootfs' partition to be root filesystem"
++	default y
++
++config MTD_ROOTFS_SPLIT
++	bool "Automatically split 'rootfs' partition for squashfs"
++	default y
++
++config MTD_SPLIT_FIRMWARE
++	bool "Automatically split firmware partition for kernel+rootfs"
++	default y
++
++config MTD_SPLIT_FIRMWARE_NAME
++	string "Firmware partition name"
++	depends on MTD_SPLIT_FIRMWARE
++	default "firmware"
++
++config MTD_UIMAGE_SPLIT
++	bool "Enable split support for firmware partitions containing a uImage"
++	depends on MTD_SPLIT_FIRMWARE
++	default y
++
++endmenu
++
+ config MTD_TESTS
+ 	tristate "MTD tests support (DANGEROUS)"
+ 	depends on m
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -29,6 +29,7 @@
+ #include <linux/kmod.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
++#include <linux/magic.h>
+ #include <linux/err.h>
+ 
+ #include "mtdcore.h"
+@@ -45,13 +46,14 @@ struct mtd_part {
+ 	struct list_head list;
+ };
+ 
++static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
++
+ /*
+  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
+  * the pointer to that structure with this macro.
+  */
+ #define PART(x)  ((struct mtd_part *)(x))
+ 
+-
+ /*
+  * MTD methods which simply translate the effective address and pass through
+  * to the _real_ device.
+@@ -533,8 +535,10 @@ out_register:
+ 	return slave;
+ }
+ 
+-int mtd_add_partition(struct mtd_info *master, char *name,
+-		      long long offset, long long length)
++
++static int
++__mtd_add_partition(struct mtd_info *master, char *name,
++		    long long offset, long long length, bool dup_check)
+ {
+ 	struct mtd_partition part;
+ 	struct mtd_part *p, *new;
+@@ -566,21 +570,24 @@ int mtd_add_partition(struct mtd_info *m
+ 	end = offset + length;
+ 
+ 	mutex_lock(&mtd_partitions_mutex);
+-	list_for_each_entry(p, &mtd_partitions, list)
+-		if (p->master == master) {
+-			if ((start >= p->offset) &&
+-			    (start < (p->offset + p->mtd.size)))
+-				goto err_inv;
+-
+-			if ((end >= p->offset) &&
+-			    (end < (p->offset + p->mtd.size)))
+-				goto err_inv;
+-		}
++	if (dup_check) {
++		list_for_each_entry(p, &mtd_partitions, list)
++			if (p->master == master) {
++				if ((start >= p->offset) &&
++				    (start < (p->offset + p->mtd.size)))
++					goto err_inv;
++
++				if ((end >= p->offset) &&
++				    (end < (p->offset + p->mtd.size)))
++					goto err_inv;
++			}
++	}
+ 
+ 	list_add(&new->list, &mtd_partitions);
+ 	mutex_unlock(&mtd_partitions_mutex);
+ 
+ 	add_mtd_device(&new->mtd);
++	mtd_partition_split(master, new);
+ 
+ 	return ret;
+ err_inv:
+@@ -590,6 +597,26 @@ err_inv:
+ }
+ EXPORT_SYMBOL_GPL(mtd_add_partition);
+ 
++/* returns the size of an MTD device */
++uint64_t mtd_get_device_size(const struct mtd_info *mtd)
++{
++	struct mtd_part *part;
++
++	if (!mtd_is_partition(mtd))
++		return mtd->size;
++
++	part = PART(mtd);
++
++	return part->master->size;
++}
++EXPORT_SYMBOL_GPL(mtd_get_device_size);
++
++int mtd_add_partition(struct mtd_info *master, char *name,
++		      long long offset, long long length)
++{
++	return __mtd_add_partition(master, name, offset, length, true);
++}
++
+ int mtd_del_partition(struct mtd_info *master, int partno)
+ {
+ 	struct mtd_part *slave, *next;
+@@ -613,6 +626,144 @@ int mtd_del_partition(struct mtd_info *m
+ }
+ EXPORT_SYMBOL_GPL(mtd_del_partition);
+ 
++static inline unsigned long
++mtd_pad_erasesize(struct mtd_info *mtd, int offset, int len)
++{
++	unsigned long mask = mtd->erasesize - 1;
++
++	len += offset & mask;
++	len = (len + mask) & ~mask;
++	len -= offset & mask;
++	return len;
++}
++
++#define ROOTFS_SPLIT_NAME "rootfs_data"
++
++struct squashfs_super_block {
++	__le32 s_magic;
++	__le32 pad0[9];
++	__le64 bytes_used;
++};
++
++
++static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
++{
++	struct squashfs_super_block sb;
++	int len, ret;
++
++	ret = mtd_read(master, offset, sizeof(sb), &len, (void *) &sb);
++	if (ret || (len != sizeof(sb))) {
++		printk(KERN_ALERT "split_squashfs: error occured while reading "
++			"from \"%s\"\n", master->name);
++		return -EINVAL;
++	}
++
++	if (SQUASHFS_MAGIC != le32_to_cpu(sb.s_magic) ) {
++		printk(KERN_ALERT "split_squashfs: no squashfs found in \"%s\"\n",
++			master->name);
++		*split_offset = 0;
++		return 0;
++	}
++
++	if (le64_to_cpu((sb.bytes_used)) <= 0) {
++		printk(KERN_ALERT "split_squashfs: squashfs is empty in \"%s\"\n",
++			master->name);
++		*split_offset = 0;
++		return 0;
++	}
++
++	len = (u32) le64_to_cpu(sb.bytes_used);
++	len = mtd_pad_erasesize(master, offset, len);
++	*split_offset = offset + len;
++
++	return 0;
++}
++
++static void split_rootfs_data(struct mtd_info *master, struct mtd_part *part)
++{
++	unsigned int split_offset = 0;
++	unsigned int split_size;
++	int ret;
++
++	ret = split_squashfs(master, part->offset, &split_offset);
++	if (ret)
++		return;
++
++	if (split_offset <= 0)
++		return;
++
++	split_size = part->mtd.size - (split_offset - part->offset);
++	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=0x%x, len=0x%x\n",
++		ROOTFS_SPLIT_NAME, split_offset, split_size);
++
++	__mtd_add_partition(master, ROOTFS_SPLIT_NAME, split_offset,
++			    split_size, false);
++}
++
++#define UBOOT_MAGIC	0x27051956
++
++static void split_uimage(struct mtd_info *master, struct mtd_part *part)
++{
++	struct {
++		__be32 magic;
++		__be32 pad[2];
++		__be32 size;
++	} hdr;
++	size_t len;
++
++	if (mtd_read(master, part->offset, sizeof(hdr), &len, (void *) &hdr))
++		return;
++
++	if (len != sizeof(hdr) || hdr.magic != cpu_to_be32(UBOOT_MAGIC))
++		return;
++
++	len = be32_to_cpu(hdr.size) + 0x40;
++	len = mtd_pad_erasesize(master, part->offset, len);
++	if (len + master->erasesize > part->mtd.size)
++		return;
++
++	__mtd_add_partition(master, "rootfs", part->offset + len,
++			    part->mtd.size - len, false);
++}
++
++#ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#else
++#define SPLIT_FIRMWARE_NAME	"unused"
++#endif
++
++static void split_firmware(struct mtd_info *master, struct mtd_part *part)
++{
++	if (config_enabled(CONFIG_MTD_UIMAGE_SPLIT))
++		split_uimage(master, part);
++}
++
++void __weak arch_split_mtd_part(struct mtd_info *master, const char *name,
++                                int offset, int size)
++{
++}
++
++static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
++{
++	static int rootfs_found = 0;
++
++	if (rootfs_found)
++		return;
++
++	if (!strcmp(part->mtd.name, "rootfs")) {
++		rootfs_found = 1;
++
++		if (config_enabled(CONFIG_MTD_ROOTFS_SPLIT))
++			split_rootfs_data(master, part);
++	}
++
++	if (!strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
++	    config_enabled(CONFIG_MTD_SPLIT_FIRMWARE))
++		split_firmware(master, part);
++
++	arch_split_mtd_part(master, part->mtd.name, part->offset,
++			    part->mtd.size);
++}
+ /*
+  * This function, given a master MTD object and a partition table, creates
+  * and registers slave MTD objects which are bound to the master according to
+@@ -642,6 +793,7 @@ int add_mtd_partitions(struct mtd_info *
+ 		mutex_unlock(&mtd_partitions_mutex);
+ 
+ 		add_mtd_device(&slave->mtd);
++		mtd_partition_split(master, slave);
+ 
+ 		cur_offset = slave->offset + slave->mtd.size;
+ 	}
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -84,5 +84,8 @@ int mtd_add_partition(struct mtd_info *m
+ 		      long long offset, long long length);
+ int mtd_del_partition(struct mtd_info *master, int partno);
++uint64_t mtd_get_device_size(const struct mtd_info *mtd);
++extern void __weak arch_split_mtd_part(struct mtd_info *master,
++				       const char *name, int offset, int size);
+ 
+ #endif
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/400-rootfs_split.patch attitude_adjustment WD/target/linux/generic/patches-3.3/400-rootfs_split.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/400-rootfs_split.patch	2014-04-17 00:00:25.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/400-rootfs_split.patch	1969-12-31 19:00:00.000000000 -0500
@@ -1,327 +0,0 @@
---- a/drivers/mtd/Kconfig
-+++ b/drivers/mtd/Kconfig
-@@ -23,6 +23,14 @@ config MTD_TESTS
- 	  WARNING: some of the tests will ERASE entire MTD device which they
- 	  test. Do not use these tests unless you really know what you do.
- 
-+config MTD_ROOTFS_ROOT_DEV
-+	bool "Automatically set 'rootfs' partition to be root filesystem"
-+	default y
-+
-+config MTD_ROOTFS_SPLIT
-+	bool "Automatically split 'rootfs' partition for squashfs"
-+	default y
-+
- config MTD_REDBOOT_PARTS
- 	tristate "RedBoot partition table parsing"
- 	---help---
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -29,6 +29,8 @@
- #include <linux/kmod.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-+#include <linux/root_dev.h>
-+#include <linux/magic.h>
- #include <linux/err.h>
- 
- #include "mtdcore.h"
-@@ -50,7 +52,7 @@ struct mtd_part {
-  * the pointer to that structure with this macro.
-  */
- #define PART(x)  ((struct mtd_part *)(x))
--
-+#define IS_PART(mtd) (mtd->read == part_read)
- 
- /*
-  * MTD methods which simply translate the effective address and pass through
-@@ -643,6 +645,155 @@ int mtd_del_partition(struct mtd_info *m
- }
- EXPORT_SYMBOL_GPL(mtd_del_partition);
- 
-+#ifdef CONFIG_MTD_ROOTFS_SPLIT
-+#define ROOTFS_SPLIT_NAME "rootfs_data"
-+#define ROOTFS_REMOVED_NAME "<removed>"
-+
-+struct squashfs_super_block {
-+	__le32 s_magic;
-+	__le32 pad0[9];
-+	__le64 bytes_used;
-+};
-+
-+
-+static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
-+{
-+	struct squashfs_super_block sb;
-+	int len, ret;
-+
-+	ret = master->read(master, offset, sizeof(sb), &len, (void *) &sb);
-+	if (ret || (len != sizeof(sb))) {
-+		printk(KERN_ALERT "split_squashfs: error occured while reading "
-+			"from \"%s\"\n", master->name);
-+		return -EINVAL;
-+	}
-+
-+	if (SQUASHFS_MAGIC != le32_to_cpu(sb.s_magic) ) {
-+		printk(KERN_ALERT "split_squashfs: no squashfs found in \"%s\"\n",
-+			master->name);
-+		*split_offset = 0;
-+		return 0;
-+	}
-+
-+	if (le64_to_cpu((sb.bytes_used)) <= 0) {
-+		printk(KERN_ALERT "split_squashfs: squashfs is empty in \"%s\"\n",
-+			master->name);
-+		*split_offset = 0;
-+		return 0;
-+	}
-+
-+	len = (u32) le64_to_cpu(sb.bytes_used);
-+	len += (offset & 0x000fffff);
-+	len +=  (master->erasesize - 1);
-+	len &= ~(master->erasesize - 1);
-+	len -= (offset & 0x000fffff);
-+	*split_offset = offset + len;
-+
-+	return 0;
-+}
-+
-+static int split_rootfs_data(struct mtd_info *master, struct mtd_info *rpart, const struct mtd_partition *part)
-+{
-+	struct mtd_partition *dpart;
-+	struct mtd_part *slave = NULL;
-+	struct mtd_part *spart;
-+	int ret, split_offset = 0;
-+
-+	spart = PART(rpart);
-+	ret = split_squashfs(master, spart->offset, &split_offset);
-+	if (ret)
-+		return ret;
-+
-+	if (split_offset <= 0)
-+		return 0;
-+
-+	dpart = kmalloc(sizeof(*part)+sizeof(ROOTFS_SPLIT_NAME)+1, GFP_KERNEL);
-+	if (dpart == NULL) {
-+		printk(KERN_INFO "split_squashfs: no memory for partition \"%s\"\n",
-+			ROOTFS_SPLIT_NAME);
-+		return -ENOMEM;
-+	}
-+
-+	memcpy(dpart, part, sizeof(*part));
-+	dpart->name = (unsigned char *)&dpart[1];
-+	strcpy(dpart->name, ROOTFS_SPLIT_NAME);
-+
-+	dpart->size = rpart->size - (split_offset - spart->offset);
-+	dpart->offset = split_offset;
-+
-+	if (dpart == NULL)
-+		return 1;
-+
-+	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=%llX, len=%llX \n",
-+		ROOTFS_SPLIT_NAME, dpart->offset, dpart->size);
-+
-+	slave = allocate_partition(master, dpart, 0, split_offset);
-+	if (IS_ERR(slave))
-+		return PTR_ERR(slave);
-+	mutex_lock(&mtd_partitions_mutex);
-+	list_add(&slave->list, &mtd_partitions);
-+	mutex_unlock(&mtd_partitions_mutex);
-+
-+	add_mtd_device(&slave->mtd);
-+
-+	rpart->split = &slave->mtd;
-+
-+	return 0;
-+}
-+
-+static int refresh_rootfs_split(struct mtd_info *mtd)
-+{
-+	struct mtd_partition tpart;
-+	struct mtd_part *part;
-+	char *name;
-+	//int index = 0;
-+	int offset, size;
-+	int ret;
-+
-+	part = PART(mtd);
-+
-+	/* check for the new squashfs offset first */
-+	ret = split_squashfs(part->master, part->offset, &offset);
-+	if (ret)
-+		return ret;
-+
-+	if ((offset > 0) && !mtd->split) {
-+		printk(KERN_INFO "%s: creating new split partition for \"%s\"\n", __func__, mtd->name);
-+		/* if we don't have a rootfs split partition, create a new one */
-+		tpart.name = (char *) mtd->name;
-+		tpart.size = mtd->size;
-+		tpart.offset = part->offset;
-+
-+		return split_rootfs_data(part->master, &part->mtd, &tpart);
-+	} else if ((offset > 0) && mtd->split) {
-+		/* update the offsets of the existing partition */
-+		size = mtd->size + part->offset - offset;
-+
-+		part = PART(mtd->split);
-+		part->offset = offset;
-+		part->mtd.size = size;
-+		printk(KERN_INFO "%s: %s partition \"" ROOTFS_SPLIT_NAME "\", offset: 0x%06x (0x%06x)\n",
-+			__func__, (!strcmp(part->mtd.name, ROOTFS_SPLIT_NAME) ? "updating" : "creating"),
-+			(u32) part->offset, (u32) part->mtd.size);
-+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
-+		strcpy(name, ROOTFS_SPLIT_NAME);
-+		part->mtd.name = name;
-+	} else if ((offset <= 0) && mtd->split) {
-+		printk(KERN_INFO "%s: removing partition \"%s\"\n", __func__, mtd->split->name);
-+
-+		/* mark existing partition as removed */
-+		part = PART(mtd->split);
-+		name = kmalloc(sizeof(ROOTFS_SPLIT_NAME) + 1, GFP_KERNEL);
-+		strcpy(name, ROOTFS_REMOVED_NAME);
-+		part->mtd.name = name;
-+		part->offset = 0;
-+		part->mtd.size = 0;
-+	}
-+
-+	return 0;
-+}
-+#endif /* CONFIG_MTD_ROOTFS_SPLIT */
-+
- /*
-  * This function, given a master MTD object and a partition table, creates
-  * and registers slave MTD objects which are bound to the master according to
-@@ -659,6 +810,9 @@ int add_mtd_partitions(struct mtd_info *
- 	struct mtd_part *slave;
- 	uint64_t cur_offset = 0;
- 	int i;
-+#ifdef CONFIG_MTD_ROOTFS_SPLIT
-+	int ret;
-+#endif
- 
- 	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
- 
-@@ -673,12 +827,53 @@ int add_mtd_partitions(struct mtd_info *
- 
- 		add_mtd_device(&slave->mtd);
- 
-+		if (!strcmp(parts[i].name, "rootfs")) {
-+#ifdef CONFIG_MTD_ROOTFS_ROOT_DEV
-+			if (ROOT_DEV == 0) {
-+				printk(KERN_NOTICE "mtd: partition \"rootfs\" "
-+					"set to be root filesystem\n");
-+				ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, slave->mtd.index);
-+			}
-+#endif
-+#ifdef CONFIG_MTD_ROOTFS_SPLIT
-+			ret = split_rootfs_data(master, &slave->mtd, &parts[i]);
-+			/* if (ret == 0)
-+			 * 	j++; */
-+#endif
-+		}
-+
- 		cur_offset = slave->offset + slave->mtd.size;
- 	}
- 
- 	return 0;
- }
- 
-+int mtd_device_refresh(struct mtd_info *mtd)
-+{
-+	int ret = 0;
-+
-+	if (IS_PART(mtd)) {
-+		struct mtd_part *part;
-+		struct mtd_info *master;
-+
-+		part = PART(mtd);
-+		master = part->master;
-+		if (master->refresh_device)
-+			ret = master->refresh_device(master);
-+	}
-+
-+	if (!ret && mtd->refresh_device)
-+		ret = mtd->refresh_device(mtd);
-+
-+#ifdef CONFIG_MTD_ROOTFS_SPLIT
-+	if (!ret && IS_PART(mtd) && !strcmp(mtd->name, "rootfs"))
-+		refresh_rootfs_split(mtd);
-+#endif
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(mtd_device_refresh);
-+
- static DEFINE_SPINLOCK(part_parser_lock);
- static LIST_HEAD(part_parsers);
- 
---- a/drivers/mtd/mtdchar.c
-+++ b/drivers/mtd/mtdchar.c
-@@ -1005,6 +1005,12 @@ static int mtdchar_ioctl(struct file *fi
- 		break;
- 	}
- 
-+	case MTDREFRESH:
-+	{
-+		ret = mtd_device_refresh(mtd);
-+		break;
-+	}
-+
- 	default:
- 		ret = -ENOTTY;
- 	}
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -114,6 +114,7 @@ struct nand_ecclayout {
- 
- struct module;	/* only needed for owner field in mtd_info */
- 
-+struct mtd_info;
- struct mtd_info {
- 	u_char type;
- 	uint32_t flags;
-@@ -214,6 +215,9 @@ struct mtd_info {
- 	int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);
- 	int (*suspend) (struct mtd_info *mtd);
- 	void (*resume) (struct mtd_info *mtd);
-+	int (*refresh_device)(struct mtd_info *mtd);
-+	struct mtd_info *split;
-+
- 	/*
- 	 * If the driver is something smart, like UBI, it may need to maintain
- 	 * its own reference counting. The below functions are only for driver.
-@@ -502,6 +506,7 @@ extern int mtd_device_parse_register(str
- 			      int defnr_parts);
- #define mtd_device_register(master, parts, nr_parts)	\
- 	mtd_device_parse_register(master, NULL, NULL, parts, nr_parts)
-+extern int mtd_device_refresh(struct mtd_info *master);
- extern int mtd_device_unregister(struct mtd_info *master);
- extern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
- extern int __get_mtd_device(struct mtd_info *mtd);
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -36,12 +36,14 @@
-  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
-  */
- 
-+struct mtd_partition;
- struct mtd_partition {
- 	char *name;			/* identifier string */
- 	uint64_t size;			/* partition size */
- 	uint64_t offset;		/* offset within the master MTD space */
- 	uint32_t mask_flags;		/* master MTD flags to mask out for this partition */
- 	struct nand_ecclayout *ecclayout;	/* out of band layout for this partition (NAND only) */
-+	int (*refresh_partition)(struct mtd_info *);
- };
- 
- #define MTDPART_OFS_RETAIN	(-3)
---- a/include/mtd/mtd-abi.h
-+++ b/include/mtd/mtd-abi.h
-@@ -202,6 +202,7 @@ struct otp_info {
-  * without OOB, e.g., NOR flash.
-  */
- #define MEMWRITE		_IOWR('M', 24, struct mtd_write_req)
-+#define MTDREFRESH		_IO('M', 50)
- 
- /*
-  * Obsolete legacy interface. Keep it in order not to break userspace
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/401-mtd-add-support-for-different-partition-parser-types.patch attitude_adjustment WD/target/linux/generic/patches-3.3/401-mtd-add-support-for-different-partition-parser-types.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/401-mtd-add-support-for-different-partition-parser-types.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/401-mtd-add-support-for-different-partition-parser-types.patch	2014-04-20 19:58:19.000000000 -0400
@@ -0,0 +1,113 @@
+From 02cff0ccaa6d364f5c1eeea83f47ac80ccc967d4 Mon Sep 17 00:00:00 2001
+From: Gabor Juhos <juhosg@openwrt.org>
+Date: Tue, 3 Sep 2013 18:11:50 +0200
+Subject: [PATCH] mtd: add support for different partition parser types
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+ drivers/mtd/mtdpart.c          |   56 ++++++++++++++++++++++++++++++++++++++++
+ include/linux/mtd/partitions.h |   11 ++++++++
+ 2 files changed, 67 insertions(+)
+
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -867,6 +867,30 @@ static struct mtd_part_parser *get_parti
+ 
+ #define put_partition_parser(p) do { module_put((p)->owner); } while (0)
+ 
++static struct mtd_part_parser *
++get_partition_parser_by_type(enum mtd_parser_type type,
++			     struct mtd_part_parser *start)
++{
++	struct mtd_part_parser *p, *ret = NULL;
++
++	spin_lock(&part_parser_lock);
++
++	p = list_prepare_entry(start, &part_parsers, list);
++	if (start)
++		put_partition_parser(start);
++
++	list_for_each_entry_continue(p, &part_parsers, list) {
++		if (p->type == type && try_module_get(p->owner)) {
++			ret = p;
++			break;
++		}
++	}
++
++	spin_unlock(&part_parser_lock);
++
++	return ret;
++}
++
+ int register_mtd_parser(struct mtd_part_parser *p)
+ {
+ 	spin_lock(&part_parser_lock);
+@@ -916,6 +964,38 @@ int parse_mtd_partitions(struct mtd_info
+ 	return ret;
+ }
+ 
++int parse_mtd_partitions_by_type(struct mtd_info *master,
++				 enum mtd_parser_type type,
++				 struct mtd_partition **pparts,
++				 struct mtd_part_parser_data *data)
++{
++	struct mtd_part_parser *prev = NULL;
++	int ret = 0;
++
++	while (1) {
++		struct mtd_part_parser *parser;
++
++		parser = get_partition_parser_by_type(type, prev);
++		if (!parser)
++			break;
++
++		ret = (*parser->parse_fn)(master, pparts, data);
++
++		if (ret > 0) {
++			put_partition_parser(parser);
++			printk(KERN_NOTICE
++			       "%d %s partitions found on MTD device %s\n",
++			       ret, parser->name, master->name);
++			break;
++		}
++
++		prev = parser;
++	}
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(parse_mtd_partitions_by_type);
++
+ int mtd_is_partition(struct mtd_info *mtd)
+ {
+ 	struct mtd_part *part;
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -68,12 +68,17 @@ struct mtd_part_parser_data {
+  * Functions dealing with the various ways of partitioning the space
+  */
+ 
++enum mtd_parser_type {
++	MTD_PARSER_TYPE_DEVICE = 0,
++};
++
+ struct mtd_part_parser {
+ 	struct list_head list;
+ 	struct module *owner;
+ 	const char *name;
+ 	int (*parse_fn)(struct mtd_info *, struct mtd_partition **,
+ 			struct mtd_part_parser_data *);
++	enum mtd_parser_type type;
+ };
+ 
+ extern int register_mtd_parser(struct mtd_part_parser *parser);
+@@ -87,4 +92,9 @@ uint64_t mtd_get_device_size(const struc
+ extern void __weak arch_split_mtd_part(struct mtd_info *master,
+ 				       const char *name, int offset, int size);
+ 
++int parse_mtd_partitions_by_type(struct mtd_info *master,
++				 enum mtd_parser_type type,
++				 struct mtd_partition **pparts,
++				 struct mtd_part_parser_data *data);
++
+ #endif
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/401-partial_eraseblock_write.patch attitude_adjustment WD/target/linux/generic/patches-3.3/401-partial_eraseblock_write.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/401-partial_eraseblock_write.patch	2014-04-17 00:00:25.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/401-partial_eraseblock_write.patch	1969-12-31 19:00:00.000000000 -0500
@@ -1,145 +0,0 @@
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -35,6 +35,8 @@
- 
- #include "mtdcore.h"
- 
-+#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
-+
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
- static DEFINE_MUTEX(mtd_partitions_mutex);
-@@ -252,13 +254,60 @@ static int part_erase(struct mtd_info *m
- 		return -EROFS;
- 	if (instr->addr >= mtd->size)
- 		return -EINVAL;
-+
-+	instr->partial_start = false;
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		size_t readlen = 0;
-+		u64 mtd_ofs;
-+
-+		instr->erase_buf = kmalloc(part->master->erasesize, GFP_ATOMIC);
-+		if (!instr->erase_buf)
-+			return -ENOMEM;
-+
-+		mtd_ofs = part->offset + instr->addr;
-+		instr->erase_buf_ofs = do_div(mtd_ofs, part->master->erasesize);
-+
-+		if (instr->erase_buf_ofs > 0) {
-+			instr->addr -= instr->erase_buf_ofs;
-+			ret = mtd_read(part->master,
-+				instr->addr + part->offset,
-+				part->master->erasesize,
-+				&readlen, instr->erase_buf);
-+
-+			instr->partial_start = true;
-+		} else {
-+			mtd_ofs = part->offset + part->mtd.size;
-+			instr->erase_buf_ofs = part->master->erasesize -
-+				do_div(mtd_ofs, part->master->erasesize);
-+
-+			if (instr->erase_buf_ofs > 0) {
-+				instr->len += instr->erase_buf_ofs;
-+				ret = mtd_read(part->master,
-+					part->offset + instr->addr +
-+					instr->len - part->master->erasesize,
-+					part->master->erasesize, &readlen,
-+					instr->erase_buf);
-+			} else {
-+				ret = 0;
-+			}
-+		}
-+		if (ret < 0) {
-+			kfree(instr->erase_buf);
-+			return ret;
-+		}
-+
-+	}
-+
- 	instr->addr += part->offset;
- 	ret = mtd_erase(part->master, instr);
- 	if (ret) {
- 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 			instr->fail_addr -= part->offset;
- 		instr->addr -= part->offset;
-+		if (mtd->flags & MTD_ERASE_PARTIAL)
-+			kfree(instr->erase_buf);
- 	}
-+
- 	return ret;
- }
- 
-@@ -266,7 +315,25 @@ void mtd_erase_callback(struct erase_inf
- {
- 	if (instr->mtd->erase == part_erase) {
- 		struct mtd_part *part = PART(instr->mtd);
-+		size_t wrlen = 0;
- 
-+		if (instr->mtd->flags & MTD_ERASE_PARTIAL) {
-+			if (instr->partial_start) {
-+				part->master->write(part->master,
-+					instr->addr, instr->erase_buf_ofs,
-+					&wrlen, instr->erase_buf);
-+				instr->addr += instr->erase_buf_ofs;
-+			} else {
-+				instr->len -= instr->erase_buf_ofs;
-+				part->master->write(part->master,
-+					instr->addr + instr->len,
-+					instr->erase_buf_ofs, &wrlen,
-+					instr->erase_buf +
-+					part->master->erasesize -
-+					instr->erase_buf_ofs);
-+			}
-+			kfree(instr->erase_buf);
-+		}
- 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 			instr->fail_addr -= part->offset;
- 		instr->addr -= part->offset;
-@@ -537,18 +604,24 @@ static struct mtd_part *allocate_partiti
- 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
- 	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
- 		/* Doesn't start on a boundary of major erase size */
--		/* FIXME: Let it be writable if it is on a boundary of
--		 * _minor_ erase size though */
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+		if (((u32) slave->mtd.size) > master->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
--	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
--			part->name);
-+	    mtd_mod_by_eb(slave->offset + slave->mtd.size, &slave->mtd)) {
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+
-+		if ((u32) slave->mtd.size > master->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
-+	if ((slave->mtd.flags & (MTD_ERASE_PARTIAL|MTD_WRITEABLE)) == MTD_ERASE_PARTIAL)
-+		printk(KERN_WARNING"mtd: partition \"%s\" must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only\n",
-+				part->name);
- 
- 	slave->mtd.ecclayout = master->ecclayout;
- 	if (master->block_isbad) {
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -58,6 +58,10 @@ struct erase_info {
- 	u_long priv;
- 	u_char state;
- 	struct erase_info *next;
-+
-+	u8 *erase_buf;
-+	u32 erase_buf_ofs;
-+	bool partial_start;
- };
- 
- struct mtd_erase_region_info {
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch attitude_adjustment WD/target/linux/generic/patches-3.3/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/402-mtd-use-typed-mtd-parsers-for-rootfs-and-firmware-split.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,75 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -626,6 +626,37 @@ int mtd_del_partition(struct mtd_info *m
+ }
+ EXPORT_SYMBOL_GPL(mtd_del_partition);
+ 
++static int
++run_parsers_by_type(struct mtd_part *slave, enum mtd_parser_type type)
++{
++	struct mtd_partition *parts;
++	int nr_parts;
++	int i;
++
++	nr_parts = parse_mtd_partitions_by_type(&slave->mtd, type, &parts,
++						NULL);
++	if (nr_parts <= 0)
++		return nr_parts;
++
++	if (WARN_ON(!parts))
++		return 0;
++
++	for (i = 0; i < nr_parts; i++) {
++		/* adjust partition offsets */
++		parts[i].offset += slave->offset;
++
++		__mtd_add_partition(slave->master,
++				    parts[i].name,
++				    parts[i].offset,
++				    parts[i].size,
++				    false);
++	}
++
++	kfree(parts);
++
++	return nr_parts;
++}
++
+ static inline unsigned long
+ mtd_pad_erasesize(struct mtd_info *mtd, int offset, int len)
+ {
+@@ -685,6 +716,10 @@ static void split_rootfs_data(struct mtd
+ 	unsigned int split_size;
+ 	int ret;
+ 
++	ret = run_parsers_by_type(part, MTD_PARSER_TYPE_ROOTFS);
++	if (ret > 0)
++		return;
++
+ 	ret = split_squashfs(master, part->offset, &split_offset);
+ 	if (ret)
+ 		return;
+@@ -734,6 +769,12 @@ static void split_uimage(struct mtd_info
+ 
+ static void split_firmware(struct mtd_info *master, struct mtd_part *part)
+ {
++	int ret;
++
++	ret = run_parsers_by_type(part, MTD_PARSER_TYPE_FIRMWARE);
++	if (ret > 0)
++		return;
++
+ 	if (config_enabled(CONFIG_MTD_UIMAGE_SPLIT))
+ 		split_uimage(master, part);
+ }
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -70,6 +70,8 @@ struct mtd_part_parser_data {
+ 
+ enum mtd_parser_type {
+ 	MTD_PARSER_TYPE_DEVICE = 0,
++	MTD_PARSER_TYPE_ROOTFS,
++	MTD_PARSER_TYPE_FIRMWARE,
+ };
+ 
+ struct mtd_part_parser {
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/403-mtd-hook-mtdsplit-to-Kbuild.patch attitude_adjustment WD/target/linux/generic/patches-3.3/403-mtd-hook-mtdsplit-to-Kbuild.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/403-mtd-hook-mtdsplit-to-Kbuild.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/403-mtd-hook-mtdsplit-to-Kbuild.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,25 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -36,6 +36,11 @@ config MTD_UIMAGE_SPLIT
+ 	depends on MTD_SPLIT_FIRMWARE
+ 	default y
+ 
++config MTD_SPLIT
++	def_bool n
++	help 
++	  Generic MTD split support.
++
+ endmenu
+ 
+ config MTD_TESTS
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -6,6 +6,8 @@
+ obj-$(CONFIG_MTD)		+= mtd.o
+ mtd-y				:= mtdcore.o mtdsuper.o mtdconcat.o mtdpart.o mtdchar.o
+ 
++mtd-$(CONFIG_MTD_SPLIT)		+= mtdsplit.o
++
+ obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
+ obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
+ obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/404-mtd-use-mtd_get_squashfs_len-in-split_squasfh.patch attitude_adjustment WD/target/linux/generic/patches-3.3/404-mtd-use-mtd_get_squashfs_len-in-split_squasfh.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/404-mtd-use-mtd_get_squashfs_len-in-split_squasfh.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/404-mtd-use-mtd_get_squashfs_len-in-split_squasfh.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,69 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -33,6 +33,7 @@
+ #include <linux/err.h>
+ 
+ #include "mtdcore.h"
++#include "mtdsplit.h"
+ 
+ /* Our partition linked list */
+ static LIST_HEAD(mtd_partitions);
+@@ -668,43 +669,16 @@ mtd_pad_erasesize(struct mtd_info *mtd,
+ 	return len;
+ }
+ 
+-#define ROOTFS_SPLIT_NAME "rootfs_data"
+-
+-struct squashfs_super_block {
+-	__le32 s_magic;
+-	__le32 pad0[9];
+-	__le64 bytes_used;
+-};
+-
+-
+ static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
+ {
+-	struct squashfs_super_block sb;
++	size_t squashfs_len;
+ 	int len, ret;
+ 
+-	ret = mtd_read(master, offset, sizeof(sb), &len, (void *) &sb);
+-	if (ret || (len != sizeof(sb))) {
+-		printk(KERN_ALERT "split_squashfs: error occured while reading "
+-			"from \"%s\"\n", master->name);
+-		return -EINVAL;
+-	}
+-
+-	if (SQUASHFS_MAGIC != le32_to_cpu(sb.s_magic) ) {
+-		printk(KERN_ALERT "split_squashfs: no squashfs found in \"%s\"\n",
+-			master->name);
+-		*split_offset = 0;
+-		return 0;
+-	}
+-
+-	if (le64_to_cpu((sb.bytes_used)) <= 0) {
+-		printk(KERN_ALERT "split_squashfs: squashfs is empty in \"%s\"\n",
+-			master->name);
+-		*split_offset = 0;
+-		return 0;
+-	}
++	ret = mtd_get_squashfs_len(master, offset, &squashfs_len);
++	if (ret)
++		return ret;
+ 
+-	len = (u32) le64_to_cpu(sb.bytes_used);
+-	len = mtd_pad_erasesize(master, offset, len);
++	len = mtd_pad_erasesize(master, offset, squashfs_len);
+ 	*split_offset = offset + len;
+ 
+ 	return 0;
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -20,6 +20,7 @@ config MTD_ROOTFS_ROOT_DEV
+ 
+ config MTD_ROOTFS_SPLIT
+ 	bool "Automatically split 'rootfs' partition for squashfs"
++	select MTD_SPLIT
+ 	default y
+ 
+ config MTD_SPLIT_FIRMWARE
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/405-mtd-add-more-helper-functions.patch attitude_adjustment WD/target/linux/generic/patches-3.3/405-mtd-add-more-helper-functions.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/405-mtd-add-more-helper-functions.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/405-mtd-add-more-helper-functions.patch	2014-04-20 23:26:23.000000000 -0400
@@ -0,0 +1,81 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -434,14 +434,12 @@ static struct mtd_part *allocate_partiti
+ 	if (slave->offset == MTDPART_OFS_APPEND)
+ 		slave->offset = cur_offset;
+ 	if (slave->offset == MTDPART_OFS_NXTBLK) {
+-		slave->offset = cur_offset;
+-		if (mtd_mod_by_eb(cur_offset, master) != 0) {
+-			/* Round up to next erasesize */
+-			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
++		/* Round up to next erasesize */
++		slave->offset = mtd_roundup_to_eb(cur_offset, master);
++		if (slave->offset != cur_offset)
+ 			printk(KERN_NOTICE "Moving partition %d: "
+ 			       "0x%012llx -> 0x%012llx\n", partno,
+ 			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
+-		}
+ 	}
+ 	if (slave->offset == MTDPART_OFS_RETAIN) {
+ 		slave->offset = cur_offset;
+@@ -1053,3 +1050,22 @@
+ 	return ispart;
+ }
+ EXPORT_SYMBOL_GPL(mtd_is_partition);
++
++struct mtd_info *mtdpart_get_master(struct mtd_info *mtd)
++{
++	if (!mtd_is_partition(mtd))
++		return (struct mtd_info *)mtd;
++
++	return PART(mtd)->master;
++}
++EXPORT_SYMBOL_GPL(mtdpart_get_master);
++
++uint64_t mtdpart_get_offset(const struct mtd_info *mtd)
++{
++	if (!mtd_is_partition(mtd))
++		return 0;
++
++	return PART(mtd)->offset;
++}
++EXPORT_SYMBOL_GPL(mtdpart_get_offset);
++
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -90,6 +90,8 @@ int mtd_is_partition(const struct mtd_in
+ int mtd_add_partition(struct mtd_info *master, char *name,
+ 		      long long offset, long long length);
+ int mtd_del_partition(struct mtd_info *master, int partno);
++struct mtd_info *mtdpart_get_master(struct mtd_info *mtd);
++uint64_t mtdpart_get_offset(const struct mtd_info *mtd);
+ uint64_t mtd_get_device_size(const struct mtd_info *mtd);
+ extern void __weak arch_split_mtd_part(struct mtd_info *master,
+ 				       const char *name, int offset, int size);
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -331,6 +331,24 @@ static inline uint32_t mtd_mod_by_eb(uin
+ 	return do_div(sz, mtd->erasesize);
+ }
+ 
++static inline uint64_t mtd_roundup_to_eb(uint64_t sz, struct mtd_info *mtd)
++{
++	if (mtd_mod_by_eb(sz, mtd) == 0)
++		return sz;
++
++	/* Round up to next erase block */
++	return (mtd_div_by_eb(sz, mtd) + 1) * mtd->erasesize;
++}
++
++static inline uint64_t mtd_rounddown_to_eb(uint64_t sz, struct mtd_info *mtd)
++{
++	if (mtd_mod_by_eb(sz, mtd) == 0)
++		return sz;
++
++	/* Round down to the start of the current erase block */
++	return (mtd_div_by_eb(sz, mtd)) * mtd->erasesize;
++}
++
+ static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
+ {
+ 	if (mtd->writesize_shift)
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/406-mtd-add-squashfs-parser.patch attitude_adjustment WD/target/linux/generic/patches-3.3/406-mtd-add-squashfs-parser.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/406-mtd-add-squashfs-parser.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/406-mtd-add-squashfs-parser.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,30 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -37,6 +37,17 @@ config MTD_UIMAGE_SPLIT
+ 	depends on MTD_SPLIT_FIRMWARE
+ 	default y
+ 
++comment "Rootfs partition parsers"
++
++config MTD_SPLIT_SQUASHFS_ROOT
++	bool "Squashfs based root partition parser"
++	select MTD_SPLIT
++	default n
++	help
++	  This provides a parsing function which allows to detect the
++	  offset and size of the unused portion of a rootfs partition
++	  containing a squashfs.
++
+ config MTD_SPLIT
+ 	def_bool n
+ 	help 
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -7,6 +7,7 @@ obj-$(CONFIG_MTD)		+= mtd.o
+ mtd-y				:= mtdcore.o mtdsuper.o mtdconcat.o mtdpart.o mtdchar.o
+ 
+ mtd-$(CONFIG_MTD_SPLIT)		+= mtdsplit.o
++mtd-$(CONFIG_MTD_SPLIT_SQUASHFS_ROOT) += mtdsplit_squashfs.o
+ 
+ obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
+ obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/407-mtd-hook-mtdsplit_uimage-into-Kbuild.patch attitude_adjustment WD/target/linux/generic/patches-3.3/407-mtd-hook-mtdsplit_uimage-into-Kbuild.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/407-mtd-hook-mtdsplit_uimage-into-Kbuild.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/407-mtd-hook-mtdsplit_uimage-into-Kbuild.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,25 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -48,6 +48,12 @@ config MTD_SPLIT_SQUASHFS_ROOT
+ 	  offset and size of the unused portion of a rootfs partition
+ 	  containing a squashfs.
+ 
++comment "Firmware partition parsers"
++
++config MTD_SPLIT_UIMAGE_FW
++	bool "uImage based firmware partition parser"
++	select MTD_SPLIT
++
+ config MTD_SPLIT
+ 	def_bool n
+ 	help 
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -8,6 +8,7 @@ mtd-y				:= mtdcore.o mtdsuper.o mtdconc
+ 
+ mtd-$(CONFIG_MTD_SPLIT)		+= mtdsplit.o
+ mtd-$(CONFIG_MTD_SPLIT_SQUASHFS_ROOT) += mtdsplit_squashfs.o
++mtd-$(CONFIG_MTD_SPLIT_UIMAGE_FW) += mtdsplit_uimage.o
+ 
+ obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
+ obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/408-mtd-hook-mtdsplit_seama-into-Kbuild.patch attitude_adjustment WD/target/linux/generic/patches-3.3/408-mtd-hook-mtdsplit_seama-into-Kbuild.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/408-mtd-hook-mtdsplit_seama-into-Kbuild.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/408-mtd-hook-mtdsplit_seama-into-Kbuild.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,23 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -50,6 +50,10 @@ config MTD_SPLIT_SQUASHFS_ROOT
+ 
+ comment "Firmware partition parsers"
+ 
++config MTD_SPLIT_SEAMA_FW
++	bool "Seama firmware parser"
++	select MTD_SPLIT
++
+ config MTD_SPLIT_UIMAGE_FW
+ 	bool "uImage based firmware partition parser"
+ 	select MTD_SPLIT
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -7,6 +7,7 @@ obj-$(CONFIG_MTD)		+= mtd.o
+ mtd-y				:= mtdcore.o mtdsuper.o mtdconcat.o mtdpart.o mtdchar.o
+ 
+ mtd-$(CONFIG_MTD_SPLIT)		+= mtdsplit.o
++mtd-$(CONFIG_MTD_SPLIT_SEAMA_FW) += mtdsplit_seama.o
+ mtd-$(CONFIG_MTD_SPLIT_SQUASHFS_ROOT) += mtdsplit_squashfs.o
+ mtd-$(CONFIG_MTD_SPLIT_UIMAGE_FW) += mtdsplit_uimage.o
+ 
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/409-mtd-hook-mtdsplit_lzma-into-Kbuild.patch attitude_adjustment WD/target/linux/generic/patches-3.3/409-mtd-hook-mtdsplit_lzma-into-Kbuild.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/409-mtd-hook-mtdsplit_lzma-into-Kbuild.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/409-mtd-hook-mtdsplit_lzma-into-Kbuild.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,23 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -58,6 +58,10 @@ config MTD_SPLIT_UIMAGE_FW
+ 	bool "uImage based firmware partition parser"
+ 	select MTD_SPLIT
+ 
++config MTD_SPLIT_LZMA_FW
++	bool "LZMA compressed kernel based firmware partition parser"
++	select MTD_SPLIT
++
+ config MTD_SPLIT
+ 	def_bool n
+ 	help 
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -10,6 +10,7 @@ mtd-$(CONFIG_MTD_SPLIT)		+= mtdsplit.o
+ mtd-$(CONFIG_MTD_SPLIT_SEAMA_FW) += mtdsplit_seama.o
+ mtd-$(CONFIG_MTD_SPLIT_SQUASHFS_ROOT) += mtdsplit_squashfs.o
+ mtd-$(CONFIG_MTD_SPLIT_UIMAGE_FW) += mtdsplit_uimage.o
++mtd-$(CONFIG_MTD_SPLIT_LZMA_FW) += mtdsplit_lzma.o
+ 
+ obj-$(CONFIG_MTD_OF_PARTS)	+= ofpart.o
+ obj-$(CONFIG_MTD_REDBOOT_PARTS) += redboot.o
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/410-mtd-move-forward-declaration-of-struct-mtd_info.patch attitude_adjustment WD/target/linux/generic/patches-3.3/410-mtd-move-forward-declaration-of-struct-mtd_info.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/410-mtd-move-forward-declaration-of-struct-mtd_info.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/410-mtd-move-forward-declaration-of-struct-mtd_info.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,18 @@
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -35,6 +35,7 @@
+  * Note: writeable partitions require their size and offset be
+  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
+  */
++struct mtd_info;
+ 
+ struct mtd_partition {
+ 	char *name;			/* identifier string */
+@@ -50,7 +51,6 @@ struct mtd_partition {
+ #define MTDPART_SIZ_FULL	(0)
+ 
+ 
+-struct mtd_info;
+ struct device_node;
+ 
+ /**
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/410-mtd_info_move_forward_decl.patch attitude_adjustment WD/target/linux/generic/patches-3.3/410-mtd_info_move_forward_decl.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/410-mtd_info_move_forward_decl.patch	2014-04-17 00:00:25.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/410-mtd_info_move_forward_decl.patch	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -35,6 +35,7 @@
-  * Note: writeable partitions require their size and offset be
-  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
-  */
-+struct mtd_info;
- 
- struct mtd_partition;
- struct mtd_partition {
-@@ -52,7 +53,6 @@ struct mtd_partition {
- #define MTDPART_SIZ_FULL	(0)
- 
- 
--struct mtd_info;
- struct device_node;
- 
- /**
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/411-OLD401-partial_eraseblock_write.patch attitude_adjustment WD/target/linux/generic/patches-3.3/411-OLD401-partial_eraseblock_write.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/411-OLD401-partial_eraseblock_write.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/411-OLD401-partial_eraseblock_write.patch	2014-04-17 00:00:25.000000000 -0400
@@ -0,0 +1,145 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -35,6 +35,8 @@
+ 
+ #include "mtdcore.h"
+ 
++#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
++
+ /* Our partition linked list */
+ static LIST_HEAD(mtd_partitions);
+ static DEFINE_MUTEX(mtd_partitions_mutex);
+@@ -252,13 +254,60 @@ static int part_erase(struct mtd_info *m
+ 		return -EROFS;
+ 	if (instr->addr >= mtd->size)
+ 		return -EINVAL;
++
++	instr->partial_start = false;
++	if (mtd->flags & MTD_ERASE_PARTIAL) {
++		size_t readlen = 0;
++		u64 mtd_ofs;
++
++		instr->erase_buf = kmalloc(part->master->erasesize, GFP_ATOMIC);
++		if (!instr->erase_buf)
++			return -ENOMEM;
++
++		mtd_ofs = part->offset + instr->addr;
++		instr->erase_buf_ofs = do_div(mtd_ofs, part->master->erasesize);
++
++		if (instr->erase_buf_ofs > 0) {
++			instr->addr -= instr->erase_buf_ofs;
++			ret = mtd_read(part->master,
++				instr->addr + part->offset,
++				part->master->erasesize,
++				&readlen, instr->erase_buf);
++
++			instr->partial_start = true;
++		} else {
++			mtd_ofs = part->offset + part->mtd.size;
++			instr->erase_buf_ofs = part->master->erasesize -
++				do_div(mtd_ofs, part->master->erasesize);
++
++			if (instr->erase_buf_ofs > 0) {
++				instr->len += instr->erase_buf_ofs;
++				ret = mtd_read(part->master,
++					part->offset + instr->addr +
++					instr->len - part->master->erasesize,
++					part->master->erasesize, &readlen,
++					instr->erase_buf);
++			} else {
++				ret = 0;
++			}
++		}
++		if (ret < 0) {
++			kfree(instr->erase_buf);
++			return ret;
++		}
++
++	}
++
+ 	instr->addr += part->offset;
+ 	ret = mtd_erase(part->master, instr);
+ 	if (ret) {
+ 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
+ 			instr->fail_addr -= part->offset;
+ 		instr->addr -= part->offset;
++		if (mtd->flags & MTD_ERASE_PARTIAL)
++			kfree(instr->erase_buf);
+ 	}
++
+ 	return ret;
+ }
+ 
+@@ -266,7 +315,25 @@ void mtd_erase_callback(struct erase_inf
+ {
+ 	if (instr->mtd->erase == part_erase) {
+ 		struct mtd_part *part = PART(instr->mtd);
++		size_t wrlen = 0;
+ 
++		if (instr->mtd->flags & MTD_ERASE_PARTIAL) {
++			if (instr->partial_start) {
++				part->master->write(part->master,
++					instr->addr, instr->erase_buf_ofs,
++					&wrlen, instr->erase_buf);
++				instr->addr += instr->erase_buf_ofs;
++			} else {
++				instr->len -= instr->erase_buf_ofs;
++				part->master->write(part->master,
++					instr->addr + instr->len,
++					instr->erase_buf_ofs, &wrlen,
++					instr->erase_buf +
++					part->master->erasesize -
++					instr->erase_buf_ofs);
++			}
++			kfree(instr->erase_buf);
++		}
+ 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
+ 			instr->fail_addr -= part->offset;
+ 		instr->addr -= part->offset;
+@@ -537,18 +604,24 @@ static struct mtd_part *allocate_partiti
+ 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
+ 	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
+ 		/* Doesn't start on a boundary of major erase size */
+-		/* FIXME: Let it be writable if it is on a boundary of
+-		 * _minor_ erase size though */
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
+-			part->name);
++		slave->mtd.flags |= MTD_ERASE_PARTIAL;
++		if (((u32) slave->mtd.size) > master->erasesize)
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++		else
++			slave->mtd.erasesize = slave->mtd.size;
+ 	}
+ 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
+-	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
+-			part->name);
++	    mtd_mod_by_eb(slave->offset + slave->mtd.size, &slave->mtd)) {
++		slave->mtd.flags |= MTD_ERASE_PARTIAL;
++
++		if ((u32) slave->mtd.size > master->erasesize)
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++		else
++			slave->mtd.erasesize = slave->mtd.size;
+ 	}
++	if ((slave->mtd.flags & (MTD_ERASE_PARTIAL|MTD_WRITEABLE)) == MTD_ERASE_PARTIAL)
++		printk(KERN_WARNING"mtd: partition \"%s\" must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only\n",
++				part->name);
+ 
+ 	slave->mtd.ecclayout = master->ecclayout;
+ 	if (master->block_isbad) {
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -58,6 +58,10 @@ struct erase_info {
+ 	u_long priv;
+ 	u_char state;
+ 	struct erase_info *next;
++
++	u8 *erase_buf;
++	u32 erase_buf_ofs;
++	bool partial_start;
+ };
+ 
+ struct mtd_erase_region_info {
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/415-mtd-add-config_enabled.patch attitude_adjustment WD/target/linux/generic/patches-3.3/415-mtd-add-config_enabled.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/415-mtd-add-config_enabled.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/415-mtd-add-config_enabled.patch	2014-04-21 23:45:20.000000000 -0400
@@ -0,0 +1,13 @@
+--- a/drivers/mtd/mtdcore.h	2012-06-01 03:16:13.000000000 -0400
++++ b/drivers/mtd/mtdcore.h	2014-04-21 23:40:58.000000000 -0400
+@@ -23,3 +23,10 @@
+ 	for ((mtd) = __mtd_next_device(0);		\
+ 	     (mtd) != NULL;				\
+ 	     (mtd) = __mtd_next_device(mtd->index + 1))
++
++/* linux-xxx/include/linux/kconfig.h */
++#define __ARG_PLACEHOLDER_1 0,
++#define config_enabled(cfg) _config_enabled(cfg)
++#define _config_enabled(value) __config_enabled(__ARG_PLACEHOLDER_##value)
++#define __config_enabled(arg1_or_junk) ___config_enabled(arg1_or_junk 1, 0)
++#define ___config_enabled(__ignored, val, ...) val
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/478-mtd-partial_eraseblock_unlock.patch attitude_adjustment WD/target/linux/generic/patches-3.3/478-mtd-partial_eraseblock_unlock.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/478-mtd-partial_eraseblock_unlock.patch	2014-04-17 00:00:25.000000000 -0400
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/478-mtd-partial_eraseblock_unlock.patch	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -356,7 +356,14 @@ static int part_unlock(struct mtd_info *
- 	struct mtd_part *part = PART(mtd);
- 	if ((len + ofs) > mtd->size)
- 		return -EINVAL;
--	return mtd_unlock(part->master, ofs + part->offset, len);
-+
-+	ofs += part->offset;
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		/* round up len to next erasesize and round down offset to prev block */
-+		len = (mtd_div_by_eb(len, part->master) + 1) * part->master->erasesize;
-+		ofs &= ~(part->master->erasesize - 1);
-+	}
-+	return mtd_unlock(part->master, ofs, len);
- }
- 
- static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/480-mtd-set-rootfs-to-be-root-dev.patch attitude_adjustment WD/target/linux/generic/patches-3.3/480-mtd-set-rootfs-to-be-root-dev.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/480-mtd-set-rootfs-to-be-root-dev.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/480-mtd-set-rootfs-to-be-root-dev.patch	2014-04-21 22:20:32.000000000 -0400
@@ -0,0 +1,26 @@
+--- a/drivers/mtd/mtdcore.c	2014-04-21 22:06:54.000000000 -0400
++++ b/drivers/mtd/mtdcore.c	2014-04-21 22:17:30.000000000 -0400
+@@ -36,6 +36,7 @@
+ #include <linux/idr.h>
+ #include <linux/backing-dev.h>
+ #include <linux/gfp.h>
++#include <linux/root_dev.h>
+ 
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
+@@ -372,6 +373,15 @@ int add_mtd_device(struct mtd_info *mtd)
+ 	   of this try_ nonsense, and no bitching about it
+ 	   either. :) */
+ 	__module_get(THIS_MODULE);
++
++	if (!strcmp(mtd->name, "rootfs") &&
++	    config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++	    ROOT_DEV == 0) {
++		pr_notice("mtd: device %d (%s) set to be root filesystem\n",
++			  mtd->index, mtd->name);
++		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
++	}
++
+ 	return 0;
+ 
+ fail_added:
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/703-phy-add-detach-callback-to-struct-phy_driver.patch attitude_adjustment WD/target/linux/generic/patches-3.3/703-phy-add-detach-callback-to-struct-phy_driver.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/703-phy-add-detach-callback-to-struct-phy_driver.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/703-phy-add-detach-callback-to-struct-phy_driver.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,27 @@
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -612,6 +612,9 @@ EXPORT_SYMBOL(phy_attach);
+  */
+ void phy_detach(struct phy_device *phydev)
+ {
++	if (phydev->drv && phydev->drv->detach)
++		phydev->drv->detach(phydev);
++
+ 	phydev->attached_dev->phydev = NULL;
+ 	phydev->attached_dev = NULL;
+ 
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -432,6 +432,12 @@ struct phy_driver {
+ 	 */
+ 	int (*did_interrupt)(struct phy_device *phydev);
+ 
++	/*
++	 * Called before an ethernet device is detached
++	 * from the PHY.
++	 */
++	void (*detach)(struct phy_device *phydev);
++
+ 	/* Clears up any memory if needed */
+ 	void (*remove)(struct phy_device *phydev);
+ 
diff -pruN -x '.*' attitude_adjustment/target/linux/generic/patches-3.3/732-phy-ar8216-led-support.patch attitude_adjustment WD/target/linux/generic/patches-3.3/732-phy-ar8216-led-support.patch
--- attitude_adjustment/target/linux/generic/patches-3.3/732-phy-ar8216-led-support.patch	1969-12-31 19:00:00.000000000 -0500
+++ attitude_adjustment WD/target/linux/generic/patches-3.3/732-phy-ar8216-led-support.patch	2014-04-18 08:13:01.000000000 -0400
@@ -0,0 +1,13 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -140,6 +140,10 @@ config AR8216_PHY
+ 	select ETHERNET_PACKET_MANGLE
+ 	select SWCONFIG
+ 
++config AR8216_PHY_LEDS
++	bool "Atheros AR8216 switch LED support"
++	depends on (AR8216_PHY && LEDS_CLASS)
++
+ config RTL8306_PHY
+ 	tristate "Driver for Realtek RTL8306S switches"
+ 	select SWCONFIG
